{
    "docs": [
        {
            "location": "/",
            "text": "Summoner\n\uf618\n\n\nBienvenue sur la documentation de Summoner. Ceci est le r\u00e9sultat de mon projet de 3\u00e8me ann\u00e9e \u00e0 l'ISIMA, \u00e9cole d'ing\u00e9nieur en informatique de Clermont Ferrand.\n\n\nCe projet \u00e9tait un pr\u00e9texte pour me former \u00e0 plusieurs outils et technologie du moment ainsi que d'\u00e9tudier les diff\u00e9rentes solutions possible d'organisation de travail dans le cadre de production de POC (Proof of concept). Cette documentation est plus fonctionnel que technique voir m\u00eame informative en ce qui concerne les outils que Summoner d\u00e9ploie. Pour avoir une meilleure visibilit\u00e9 sur le travail effectu\u00e9, se r\u00e9ferer \u00e0 mon \nrapport de projet\n (volontairement vulgaris\u00e9).\n\n\nBonne lecture.\n\n\nPlus d'infos sur moi m\u00eame \nsur mon CV en ligne\n ou sur mon blog \nvirtualdonkey\n et .",
            "title": "Accueil"
        },
        {
            "location": "/#summoner",
            "text": "Bienvenue sur la documentation de Summoner. Ceci est le r\u00e9sultat de mon projet de 3\u00e8me ann\u00e9e \u00e0 l'ISIMA, \u00e9cole d'ing\u00e9nieur en informatique de Clermont Ferrand.  Ce projet \u00e9tait un pr\u00e9texte pour me former \u00e0 plusieurs outils et technologie du moment ainsi que d'\u00e9tudier les diff\u00e9rentes solutions possible d'organisation de travail dans le cadre de production de POC (Proof of concept). Cette documentation est plus fonctionnel que technique voir m\u00eame informative en ce qui concerne les outils que Summoner d\u00e9ploie. Pour avoir une meilleure visibilit\u00e9 sur le travail effectu\u00e9, se r\u00e9ferer \u00e0 mon  rapport de projet  (volontairement vulgaris\u00e9).  Bonne lecture.  Plus d'infos sur moi m\u00eame  sur mon CV en ligne  ou sur mon blog  virtualdonkey  et .",
            "title": "Summoner"
        },
        {
            "location": "/summoner/",
            "text": "Summoner\n\uf618\n\n\nSummoner est un outil de d\u00e9ploiement automatique d'outils conteneuris\u00e9s. Il a pour but initial de simplifier la mise en place d'une stack de logiciel dans le cadre de l'initiation de projet de groupe.\n\n\nActuellement, Summoner est un amas de script shell permettant l'installation, le d\u00e9ploiement des minions et l'entretien du syst\u00e8me (sauvegarde etc). Il est pr\u00e9vu de migrer tout cela pour le rendre plus simple d'utilisation et plus facilement maintenable.\n\n\nInstallation de Summoner\n\uf618\n\n\n\n\nInstallation Docker\n\n\nCreation d'un network Main\n\n\nlancement des appli contenues dans config.yml\n\n\n\n\nInstallation par script\n\uf618\n\n\nUn script d'installation, \nsummoner-setup\n, est en cours de r\u00e9alisation.\n\n\nConfiguration\n\uf618\n\n\nR\u00e8gles de nommage \n\uf618\n\n\nAfin de facilit\u00e9 l'automatisation de l'entretien du syst\u00e8me, des r\u00e8gles de nommage doivent \u00eatre respect\u00e9es.\n\n\nNommer son conteneur\n\nPar d\u00e9faut, Docker nomme les conteneurs construits via compose selon le motif suivant \n<directory>_<service>_1\n. Cela pose probl\u00e8me lors de l'entretient du l'environnement (sauvegarde des donn\u00e9es, dump des bases ...).\n\n\nPour cela, il est n\u00e9cessaire de nommer manuellement les conteneurs g\u00e9n\u00e9r\u00e9s. Pour cela, il suffit d'ajouter les options suivantes :\n\n \ncontainer_name: <name>\n dans un docker compose\n\n \n--name <name>\n en lan\u00e7ant directement le conteneur\n\n\nApplication\n\nUn conteneur d'application doit \u00eatre nomm\u00e9 comme suit :  \n\n\n\n\n<application>-<domain>\n\n\n\n\nBases de donn\u00e9es\n\nUn conteneur contenant une base de donn\u00e9es doit \u00eatre nomm\u00e9 comme suit :  \n\n\n\n\n<database_type>-<application>-<domain>\n\n\n\n\nActuellement, les bases de donn\u00e9es g\u00e9r\u00e9es sont les bases mySQL, MariaDB, MongoDB et postgreSQL.\n\n\nService suppl\u00e9mentaire\n\nChaque service compl\u00e9mentaire \u00e0 une application, si aucun service centralis\u00e9 (serveur redis install\u00e9 directement sur le serveur) n'est utilis\u00e9, devra \u00eatre contenu dans un container nomm\u00e9 avec le m\u00eame sch\u00e9ma que pour les bases de donn\u00e9es :\n\n<service>-<application>-<domain>\n\n\nExemple :\n\nPrenons pour example un conteneur Gitlab accessible sur le nom de domaine \nexample.com\n, n\u00e9cessitant une base de donn\u00e9e PostreSQL et un serveur Redis. Les trois conteneurs cr\u00e9\u00e9s seront nomm\u00e9s ainsi :\n\n \ngitlab-example.com\n pour l'application principale\n\n \nredis-gitlab-example.com\n pour le serveur redis\n* \npostgresql-gitlab-example.com\n pour la base de donn\u00e9es\n\n\nConfiguration des containers\n\uf618\n\n\nLa configuration du projet est effectu\u00e9 via un fichier \n.env\n situ\u00e9 \u00e0 la racine du \nSetup\n. Ce fichier contient les variables prenant part \u00e0 la configuration des fichier \ndocker-compose\n.\nPour d\u00e9finir ce fichier, il suffit de copier le fichier \n.env_default\n et le remplir en cons\u00e9quence.\n\n\nCes variables permettent de simplifier la cr\u00e9ation d'une configuration d'un serveur \u00e0 l'autre.\n\n\nLes minions\n\uf618\n\n\nLes minions sont les invocations de notre Summoner. Chacun tourne dans un container Docker organis\u00e9 dans un fichier compose.\n\n\nLes minions principaux\n\uf618\n\n\nCertains minions sont n\u00e9cessaires \u00e0 l'utilisation du Summoner :\n\n\n\n\nNginx\n\n\nDocker registry\n\n\n\n\nLes autres minions\n\uf618\n\n\nListe des outils disponibles gr\u00e2ce \u00e0 Summoner :\n\n\n\n\nGhost\n\n\nWordpress\n\n\nWekan\n\n\nMattermost\n\n\nNextcloud\n\n\nGitlab & Gitlab CI\n\n\n\n\nDump des bases de donn\u00e9es\n\uf618\n\n\nsummoner-database-dump\n est le script de sauvegarde des bases de donn\u00e9es utilis\u00e9es par les outils mis en place par \nSummoner\n. Concernant ce projet, deux documentations existes :\n\n La \npremi\u00e8re\n concerne les bases de donn\u00e9es \u00e0 proprement parler et aborde les m\u00e9thodes de dump et backup des donn\u00e9es.\n\n La \nseconde\n documente directement les scripts de sauvegarde utilis\u00e9s.\n\n\nBackup des bases de donn\u00e9es\n\uf618\n\n\nStay tuned\n\n\nBackup des donn\u00e9es\n\uf618\n\n\nStay tuned\n\n\nFAQ\n\uf618\n\n\nUn document FAQ est accessible \nici\n. Il ressence tout les probl\u00e8mes rencontr\u00e9s relatifs \u00e0 Docker ou certains containers et les solutions trouv\u00e9es.",
            "title": "Solution"
        },
        {
            "location": "/summoner/#summoner",
            "text": "Summoner est un outil de d\u00e9ploiement automatique d'outils conteneuris\u00e9s. Il a pour but initial de simplifier la mise en place d'une stack de logiciel dans le cadre de l'initiation de projet de groupe.  Actuellement, Summoner est un amas de script shell permettant l'installation, le d\u00e9ploiement des minions et l'entretien du syst\u00e8me (sauvegarde etc). Il est pr\u00e9vu de migrer tout cela pour le rendre plus simple d'utilisation et plus facilement maintenable.",
            "title": "Summoner"
        },
        {
            "location": "/summoner/#installation-de-summoner",
            "text": "Installation Docker  Creation d'un network Main  lancement des appli contenues dans config.yml",
            "title": "Installation de Summoner"
        },
        {
            "location": "/summoner/#installation-par-script",
            "text": "Un script d'installation,  summoner-setup , est en cours de r\u00e9alisation.",
            "title": "Installation par script"
        },
        {
            "location": "/summoner/#configuration",
            "text": "",
            "title": "Configuration"
        },
        {
            "location": "/summoner/#regles-de-nommage",
            "text": "Afin de facilit\u00e9 l'automatisation de l'entretien du syst\u00e8me, des r\u00e8gles de nommage doivent \u00eatre respect\u00e9es.  Nommer son conteneur \nPar d\u00e9faut, Docker nomme les conteneurs construits via compose selon le motif suivant  <directory>_<service>_1 . Cela pose probl\u00e8me lors de l'entretient du l'environnement (sauvegarde des donn\u00e9es, dump des bases ...).  Pour cela, il est n\u00e9cessaire de nommer manuellement les conteneurs g\u00e9n\u00e9r\u00e9s. Pour cela, il suffit d'ajouter les options suivantes :   container_name: <name>  dans un docker compose   --name <name>  en lan\u00e7ant directement le conteneur  Application \nUn conteneur d'application doit \u00eatre nomm\u00e9 comme suit :     <application>-<domain>   Bases de donn\u00e9es \nUn conteneur contenant une base de donn\u00e9es doit \u00eatre nomm\u00e9 comme suit :     <database_type>-<application>-<domain>   Actuellement, les bases de donn\u00e9es g\u00e9r\u00e9es sont les bases mySQL, MariaDB, MongoDB et postgreSQL.  Service suppl\u00e9mentaire \nChaque service compl\u00e9mentaire \u00e0 une application, si aucun service centralis\u00e9 (serveur redis install\u00e9 directement sur le serveur) n'est utilis\u00e9, devra \u00eatre contenu dans un container nomm\u00e9 avec le m\u00eame sch\u00e9ma que pour les bases de donn\u00e9es : <service>-<application>-<domain>  Exemple : \nPrenons pour example un conteneur Gitlab accessible sur le nom de domaine  example.com , n\u00e9cessitant une base de donn\u00e9e PostreSQL et un serveur Redis. Les trois conteneurs cr\u00e9\u00e9s seront nomm\u00e9s ainsi :   gitlab-example.com  pour l'application principale   redis-gitlab-example.com  pour le serveur redis\n*  postgresql-gitlab-example.com  pour la base de donn\u00e9es",
            "title": "R\u00e8gles de nommage "
        },
        {
            "location": "/summoner/#configuration-des-containers",
            "text": "La configuration du projet est effectu\u00e9 via un fichier  .env  situ\u00e9 \u00e0 la racine du  Setup . Ce fichier contient les variables prenant part \u00e0 la configuration des fichier  docker-compose .\nPour d\u00e9finir ce fichier, il suffit de copier le fichier  .env_default  et le remplir en cons\u00e9quence.  Ces variables permettent de simplifier la cr\u00e9ation d'une configuration d'un serveur \u00e0 l'autre.",
            "title": "Configuration des containers"
        },
        {
            "location": "/summoner/#les-minions",
            "text": "Les minions sont les invocations de notre Summoner. Chacun tourne dans un container Docker organis\u00e9 dans un fichier compose.",
            "title": "Les minions"
        },
        {
            "location": "/summoner/#les-minions-principaux",
            "text": "Certains minions sont n\u00e9cessaires \u00e0 l'utilisation du Summoner :   Nginx  Docker registry",
            "title": "Les minions principaux"
        },
        {
            "location": "/summoner/#les-autres-minions",
            "text": "Liste des outils disponibles gr\u00e2ce \u00e0 Summoner :   Ghost  Wordpress  Wekan  Mattermost  Nextcloud  Gitlab & Gitlab CI",
            "title": "Les autres minions"
        },
        {
            "location": "/summoner/#dump-des-bases-de-donnees",
            "text": "summoner-database-dump  est le script de sauvegarde des bases de donn\u00e9es utilis\u00e9es par les outils mis en place par  Summoner . Concernant ce projet, deux documentations existes :  La  premi\u00e8re  concerne les bases de donn\u00e9es \u00e0 proprement parler et aborde les m\u00e9thodes de dump et backup des donn\u00e9es.  La  seconde  documente directement les scripts de sauvegarde utilis\u00e9s.",
            "title": "Dump des bases de donn\u00e9es"
        },
        {
            "location": "/summoner/#backup-des-bases-de-donnees",
            "text": "Stay tuned",
            "title": "Backup des bases de donn\u00e9es"
        },
        {
            "location": "/summoner/#backup-des-donnees",
            "text": "Stay tuned",
            "title": "Backup des donn\u00e9es"
        },
        {
            "location": "/summoner/#faq",
            "text": "Un document FAQ est accessible  ici . Il ressence tout les probl\u00e8mes rencontr\u00e9s relatifs \u00e0 Docker ou certains containers et les solutions trouv\u00e9es.",
            "title": "FAQ"
        },
        {
            "location": "/wiki/DatabaseManagement/",
            "text": "Documentation sur la gestion des bases de donn\u00e9es dans un container docker\n\uf618\n\n\nPr\u00e9sentation des m\u00e9thodes de dump et backup des bases de donn\u00e9es utilis\u00e9es.\n\n\nNotes :\n\n\n\n\nDump = sauvegarde logique de la base\n\n\nBackup = sauvegarde physique de la base\n\n\n\n\n\n\nMySQL\n\uf618\n\n\nLiens :\n\n\n\n\nMySQLdump utilitaire\n\n\nMySQL backup methods\n\n\nMySQL backup strategy\n\n\n\n\nL'utilitaire \nmysqldump\n\uf618\n\n\nL'utilitaire \nmysqldump\n permet d'effectuer des backup logiques d'une base de donn\u00e9es. Il permet la cr\u00e9ation d'un fichier contenant les requ\u00eates permettant de recreer une base de donn\u00e9e et la repeupler.\n\n\nUtilisation\n\n\n\n\nmysqldump db_name > dump.sql\n permet l'export de la base de donn\u00e9e.\n\n\nmysql db_name < dump.sql\n permet de restaurer la base de donn\u00e9e.\n\n\n\n\nDans notre cas, nous utilisons la commande suivante :\n\n\n\n\nmysqldump --user root --password=$MYSQL_ROOT_PASSWORD --all-databases --single-transaction > dump.sql\n permettant la sauvegarde de toutes les bases (\n--all-databases\n) et permettant une sauvegarde consistante de bases contenant des tables InnoDB (\n--single-transaction\n).\n\n\n\n\n\nLors de la restauration du dump, la commande \u00e0 ex\u00e9cuter est la suivante :\n\nmysql --user root --password=$MYSQL_ROOT_PASSWORD < dump.sql\n\n\nDocker\n\n\nSi la base MySQL est utilis\u00e9e dans un docker :\n\n\n\n\ndocker exec some_mysql bash -c 'mysqldump --user root --password=000 --all-databases --single-transaction' >/path/to/dump/dir/dump.sql\n\n\n\n\n\n\nMariaDB\n\uf618\n\n\nLiens :\n\n\n\n\nDoc \nmysqldump\n\n\nDoc backup et restauration\n\n\n\n\nEffectuer un dump sur une base MariaDB\n\uf618\n\n\nL'utilitaire \nmysqldump\n utilis\u00e9 pour faire des sauvegardes d'une base de donn\u00e9e MariaDB. Il permet de d'exporter les param\u00e8tres d'une base dans un fichier de sauvegarde d'extension SQL, XML ou m\u00eame CSV.\n\n\nPerformance\n\n\nmysqldump\n est un processus mono thread, ce qui permet d'\u00e9viter la surcharge serveur et le ralentissement des applications qui tournent pendant la sauvegarde. Cependant, il a provoque des entr\u00e9es/sorties non n\u00e9cessaires.\n\n\nIl est recommand\u00e9 d'effectuer le dump de la base au sein du m\u00eame r\u00e9seau pour limiter la cr\u00e9ation d'entr\u00e9e/sortie. Cependant, pour garder la bande passante pour les applications, il faut l'effectuer sur une seconde carte r\u00e9seau.\n\n\nUtilisation\n\n\n\n\nmysqldump [options] db_name [table1_name ...]\n sauvegarde le/les table/s de la base s\u00e9lectionn\u00e9e.\n\n\nmysqldump [options] --database db_name ...\n sauvegarde la/les bases de donn\u00e9es\n\n\nmysqldump [options] --all-databases\n sauvegarde toutes les bases de donn\u00e9es\n\n\n\n\nOptions utiles :\n\n\n\n\n--user=[user_name]\n\n\n--password=[user_password]\n\n\n\n\nLa sortie de \nmysqldump\n se fait dans la sortie standard. Il faut donc rediriger le flux dans un fichier choisi (\nbackup_file.sql\n par exemple).\n\n\nExemple d'utilisation :\n\nPour la sauvegarde de la base MariaDB utilis\u00e9e avec l'application Nextcloud :\n\nmysqldump --user=root --password=${MYSQL_ROOT_PASSWORD} ${MYSQL_DATABASE} > /some/path/to/you/file/backup_nextcloud.sql\n\n\nNotes :\n Si les tables de la base sont des tables MylSAM (MySQL 3.23 \u00e0 MySQL 5.5), il est pr\u00e9f\u00e9rable d'utiliser l'utilitaire \nmysqlhotcopy\n.\n\n\nDocker\n\n\nDans le cas d'utilisation de la base dans un conteneur Docker (\n/!\\ chose \u00e0 ne jamais faire dans un environnement de prod\n), la commande peut \u00eatre ex\u00e9cut\u00e9e de l'ext\u00e9rieur du conteneur de cette mani\u00e8re :\n\n\n\n\ndocker exec some-mariadb sh -c 'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"' > /some/path/on/your/host/all-databases.sql\n\n\n\n\n\n\nPostgres\n\uf618\n\n\nLiens :\n\n\n\n\nDoc postgres backup SQL\n\n\nDoc postgres restore SQL\n\n\nDoc sur l'outils \npg_dump\n\n\nDoc postgres backup syst\u00e8me\n\n\nDoc postgres backup \u00e0 chaud\n\n\nBonus : doc sur la migration\n\n\nPour aller plus loin\n : pg_basebackup pour les backup de cluster\n\n\n\n\nDump\n\uf618\n\n\nTout comme pour MariaDB, un utilitaire peut \u00eatre utilis\u00e9 : \npg_dump\n. Il permet la sauvegarde rapide et simple de bases de donn\u00e9es.\n\n\nUtilisation\n\n\n\n\npg_dump dbname > backupfile.out\n [1]\n\n\npg_dump -Ft dbname > backupfile.tar\n [2]\n\n\n\n\nOptions :\n\n\n\n\n-Ft\n permet la compression en fichier .tar\n\n\n\n\nLa sortie standard de \npg_dump\n se fait dans la sortie standard, une redirection de flux est n\u00e9cessaire.\n\n\nExemple d'utilisation :\n\nPour la sauvegarde de la base postgresql utilis\u00e9e avec la plate forme Gitlab :\n\npg_dump --username=gitlab -Ft gitlabhq_production > backup.tar\n\n\nDocker\n\n\nDans le cas d'utilisation de la base dans un conteneur Docker (\n/!\\ chose \u00e0 ne jamais faire dans un environnement de prod\n), la commande peut \u00eatre ex\u00e9cut\u00e9e de l'ext\u00e9rieur du conteneur de cette mani\u00e8re :\n\n\n\n\ndocker exec some_postgres bash -c 'pg_dump --username=gitlab -Ft gitlabhq_production' > backup.tar\n\n\n\n\nRestauration SQL\n\uf618\n\n\nPlusieurs solutions sont possibles selon le backup effectu\u00e9 :\n\n\n\n\n[1] : \npsql -d dbname -f backupfile.out\n\n\n[2] : \npg_restore -C newDbName backupfile.tar\n  \n\n\n\n\npg_restore -C\n cr\u00e9er une nouvelle base, se connecte \u00e0 cette base et la peuple des donn\u00e9es du fichier de backup.\n\n\nBackup fichier / Backup \u00e0 froid\n\uf618\n\n\nCette strat\u00e9gie consiste en la sauvegarde des fichiers utilis\u00e9s par PostgreSQL pour enregistrer les donn\u00e9es. Pour cela, il suffit d'utiliser GNU tar pour compresser les fichiers du dossier contenant les donn\u00e9es de la base (dans notre cas \n/var/lib/postgresql\n).\n\n\nCependant, il y a deux restrictions \u00e0 cette m\u00e9thode :\n\n\n\n\nLe serveur doit \u00eatre arr\u00eat\u00e9 pour obtenir une sauvegarde utilisable. Il en va de m\u00eame pour la restauration.\n\n\nLa sauvegarde et la restauration doivent \u00eatre totales.\n\n\n\n\nDocker\n\n\nSi la base de donn\u00e9e tourne dans un container Docker ayant un volume li\u00e9 sur l'host, il suffit de stopper le container, d'archiver les fichiers du volume et de rallumer le container.\n\n\nRestauration d'un backup \u00e0 froid\n\uf618\n\n\nDocker\n\n\nArr\u00eatez le container, remplacer les fichiers du volume par ceux de la sauvegarde, rallumez le container.\n\n\nBackup \u00e0 chaud\n\uf618\n\n\nTout d'abord assurez-vous que l'archivage WAL est activ\u00e9 et fonctionnel.\n\n\nLe backup \u00e0 chaud n\u00e9cessite de locker les donn\u00e9es pour \u00e9viter leur modifitcation le temps de la sauvegarde. Pour cela, il faut pr\u00e9venir le serveur de l'ex\u00e9cution de la sauvegarde gr\u00e2ce \u00e0 commande SQL : \nSELECT pg_start_backup('label');\n o\u00f9 label est toute cha\u00eene de caract\u00e8re utilis\u00e9e pour identifier de fa\u00e7on unique l'op\u00e9ration de sauvegarde. Cette commande cr\u00e9e un fichier \nbackup_label\n contenant des informations sur la sauvegarde.\n\n\n\u00c0 partir de l\u00e0, il est possible d'utiliser \ntar\n ou \ncpio\n afin de sauvegarder les fichiers.\n\n\nUne fois la sauvegarde fini, pr\u00e9venez le serveur avec la commande \nSELECT pg_stop_backup();\n.\n\n\nUne fois que les fichiers des segments WAL utilis\u00e9s lors de la sauvegarde sont archiv\u00e9s de la m\u00eame fa\u00e7on qu'une partie de l'activit\u00e9 normale de sauvegarde de la base de donn\u00e9es, vous avez termin\u00e9.\n\n\nRestauration d'une sauvegarde \u00e0 chaud\n\uf618\n\n\nArr\u00eatez le postmaster s'il est en cours d'ex\u00e9cution.\n\n\nSi vous avez de la place pour le faire, copiez le r\u00e9pertoire entier des donn\u00e9es du groupe et tout tablespace dans un emplacement temporaire au cas o\u00f9 vous en auriez besoin plus tard. Notez que cette pr\u00e9caution demandera que vous ayez assez de place libre sur votre syst\u00e8me pour contenir deux copies de votre base de donn\u00e9es existante. Si vous n'avez pas assez de place, vous devez au moins copier le contenu du sous-r\u00e9pertoire pg_xlog du r\u00e9pertoire des donn\u00e9es car il pourrait contenir des journaux qui n'ont pas \u00e9t\u00e9 archiv\u00e9s avant l'arr\u00eat du serveur.\n\n\nEffacez tous les fichier et sous-r\u00e9pertoires existants sous le r\u00e9pertoire des donn\u00e9es du groupe et sous les r\u00e9pertoires racines des tablespaces que vous utilisez.\n\n\nRestaurez les fichiers de la base de donn\u00e9es \u00e0 partir de votre sauvegarde. Faites attention \u00e0 ce qu'ils soient restaur\u00e9s avec le bon propri\u00e9taire (l'utilisateur syst\u00e8me de la base de donn\u00e9es, et non pas root !) et avec les bons droits. Si vous utilisez les espaces logiques, vous v\u00e9rifirez que les liens symboliques dans pg_tblspc/ ont \u00e9t\u00e9 correctement restaur\u00e9s.\n\n\nSupprimez tout fichier pr\u00e9sent dans pg_xlog/ ; ils proviennent de la sauvegarde et sont du coup probablement obsol\u00e8tes. Si vous n'avez pas archiv\u00e9 pg_xlog/ du tout, alors re-cr\u00e9ez ce r\u00e9pertoire ainsi que le sous-r\u00e9pertoire pg_xlog/archive_status/.\n\n\nSi vous aviez des fichiers segments WAL non archiv\u00e9s que vous avez sauvegard\u00e9 dans l'\u00e9tape 2, copiez-les dans pg_xlog/ (il est mieux de les copier, pas de les d\u00e9placer, car vous aurez toujours les fichiers non modifi\u00e9s si un probl\u00e8me survient et que vous devez recommencer).\n\n\nCr\u00e9ez un fichier de commandes de r\u00e9cup\u00e9ration recovery.conf dans le r\u00e9pertoire des donn\u00e9es du groupe (voir Configuration de la r\u00e9cup\u00e9ration). De plus, vous pourriez vouloir modifier temporairement pg_hba.conf pour emp\u00eacher les utilisateurs ordinaires de se connecter tant que vous n'\u00eates pas certain que la r\u00e9cup\u00e9ration a r\u00e9ussi.\n\n\nLancez le postmaster. Le postmaster se trouvera en mode r\u00e9cup\u00e9ration et commencera la lecture des fichiers WAL archiv\u00e9s dont il a besoin. \u00c0 la fin du processus de r\u00e9cup\u00e9ration, le postmaster renommera recovery.conf en recovery.done (pour emp\u00eacher de retourner accidentellement en mode de r\u00e9cup\u00e9ration dans le cas d'un arr\u00eat brutal un peu plus tard), puis commencera les op\u00e9rations normales de la base de donn\u00e9es.\n\n\nInspectez le contenu de la base de donn\u00e9es pour vous assurer que vous avez r\u00e9cup\u00e9r\u00e9 ce que vous vouliez. Sinon, retournez \u00e0 l'\u00e9tape 1. Si tout va bien, laissez vos utilisateurs venir en restaurant le fichier pg_hba.conf \u00e0 son \u00e9tat normal.\n\n\n\n\nMongoDB\n\uf618\n\n\nLiens :\n\n\n\n\nBackup & restore tools for mongoDB\n\n\nMongoDC backups\n\n\n\n\nL'utilitaire \nmongodump\n\uf618\n\n\nL'utilitaire \nmongodump\n permet la sauvegarde binaire d'une base de donn\u00e9e dans un fichier BSON. Il est tr\u00e8s utile pour effectuer des backups de petits d\u00e9ploiements. Cependant, il n\u00e9cessite le parcours des index des tables et peut donc ralentir l'utilisation de la base par les applications.\n\n\nUtilisation\n\n\n\n\nmongodump --out dump_dir/\n permet de faire un dump binaire de la base dans le dossier \ndump_dir\n\n\nmongorestore dump_dir/\n permet la restauration de la base \u00e0 partir du dossier \ndump_dir\n\n\n\n\nDocker\n\n\nPour lancer un dump dans le container, il suffit de lancer :\n\n\ndocker exec some_mogodb bash -c 'mongodump --out /path/to/dump/dir'\n\n\nN\u00e9anmoins, pour r\u00e9cup\u00e9rer le r\u00e9sultat, il est bon de compresser le dossier et de le mettre dans le volume partag\u00e9 :\n\n\ndocker exec some_mogodb bash -c 'mongodump | tar -cvf /path/to/shared/volume/file.tar'\n\n\nLe snapshot du filesystem\n\uf618\n\n\nLiens :\n\n\n\n\nSnapshot de filesytems\n\n\n\n\nLa sauvegarde par snapshot consiste \u00e0 prendre un snapshot \u00e0 un instant t des fichiers de la base de donn\u00e9es. Ceci n'est pas une op\u00e9ration sp\u00e9cifique \u00e0 MongoDB mais \u00e0 l'OS. Les m\u00e9caniques du process d\u00e9pendent alors du systeme de stockage. Par exemple, sur Linux, il est possible d'utiliser LVM (Logical Volume Manager).\n\n\nPour avoir un snapshot convenable de la base MongoDB, il faut que la journalisation soit activ\u00e9e et que le journal des logs se trouvent dans le m\u00eame volume logique que les autres fichiers de donn\u00e9es. Sans cela, il n'est pas assur\u00e9 que le snapshot soit consistent et valide.\n\n\nUtilisation\n\n\n\n\nCr\u00e9ation d'un snapshot : \n$ lvcreate --size 100M --snapshot --name mdb-snap01 /dev/vg0/mongodb\n\n\nArchivage du snapshot : \n$ umount /dev/vg0/mdb-snap01; dd if=/dev/vg0/mdb-snap01 | gzip > mdb-snap01.gz\n\n\nRestoration du snapshot :\n\n\n\n\nlvcreate --size 1G --name mdb-new vg0\ngzip -d -c mdb-snap01.gz | dd of=/dev/vg0/mdb-new\nmount /dev/vg0/mdb-new /srv/mongodb",
            "title": "Database Management"
        },
        {
            "location": "/wiki/DatabaseManagement/#documentation-sur-la-gestion-des-bases-de-donnees-dans-un-container-docker",
            "text": "Pr\u00e9sentation des m\u00e9thodes de dump et backup des bases de donn\u00e9es utilis\u00e9es.  Notes :   Dump = sauvegarde logique de la base  Backup = sauvegarde physique de la base",
            "title": "Documentation sur la gestion des bases de donn\u00e9es dans un container docker"
        },
        {
            "location": "/wiki/DatabaseManagement/#mysql",
            "text": "Liens :   MySQLdump utilitaire  MySQL backup methods  MySQL backup strategy",
            "title": "MySQL"
        },
        {
            "location": "/wiki/DatabaseManagement/#lutilitaire-mysqldump",
            "text": "L'utilitaire  mysqldump  permet d'effectuer des backup logiques d'une base de donn\u00e9es. Il permet la cr\u00e9ation d'un fichier contenant les requ\u00eates permettant de recreer une base de donn\u00e9e et la repeupler.  Utilisation   mysqldump db_name > dump.sql  permet l'export de la base de donn\u00e9e.  mysql db_name < dump.sql  permet de restaurer la base de donn\u00e9e.   Dans notre cas, nous utilisons la commande suivante :   mysqldump --user root --password=$MYSQL_ROOT_PASSWORD --all-databases --single-transaction > dump.sql  permettant la sauvegarde de toutes les bases ( --all-databases ) et permettant une sauvegarde consistante de bases contenant des tables InnoDB ( --single-transaction ).   Lors de la restauration du dump, la commande \u00e0 ex\u00e9cuter est la suivante : mysql --user root --password=$MYSQL_ROOT_PASSWORD < dump.sql  Docker  Si la base MySQL est utilis\u00e9e dans un docker :   docker exec some_mysql bash -c 'mysqldump --user root --password=000 --all-databases --single-transaction' >/path/to/dump/dir/dump.sql",
            "title": "L'utilitaire mysqldump"
        },
        {
            "location": "/wiki/DatabaseManagement/#mariadb",
            "text": "Liens :   Doc  mysqldump  Doc backup et restauration",
            "title": "MariaDB"
        },
        {
            "location": "/wiki/DatabaseManagement/#effectuer-un-dump-sur-une-base-mariadb",
            "text": "L'utilitaire  mysqldump  utilis\u00e9 pour faire des sauvegardes d'une base de donn\u00e9e MariaDB. Il permet de d'exporter les param\u00e8tres d'une base dans un fichier de sauvegarde d'extension SQL, XML ou m\u00eame CSV.  Performance  mysqldump  est un processus mono thread, ce qui permet d'\u00e9viter la surcharge serveur et le ralentissement des applications qui tournent pendant la sauvegarde. Cependant, il a provoque des entr\u00e9es/sorties non n\u00e9cessaires.  Il est recommand\u00e9 d'effectuer le dump de la base au sein du m\u00eame r\u00e9seau pour limiter la cr\u00e9ation d'entr\u00e9e/sortie. Cependant, pour garder la bande passante pour les applications, il faut l'effectuer sur une seconde carte r\u00e9seau.  Utilisation   mysqldump [options] db_name [table1_name ...]  sauvegarde le/les table/s de la base s\u00e9lectionn\u00e9e.  mysqldump [options] --database db_name ...  sauvegarde la/les bases de donn\u00e9es  mysqldump [options] --all-databases  sauvegarde toutes les bases de donn\u00e9es   Options utiles :   --user=[user_name]  --password=[user_password]   La sortie de  mysqldump  se fait dans la sortie standard. Il faut donc rediriger le flux dans un fichier choisi ( backup_file.sql  par exemple).  Exemple d'utilisation : \nPour la sauvegarde de la base MariaDB utilis\u00e9e avec l'application Nextcloud : mysqldump --user=root --password=${MYSQL_ROOT_PASSWORD} ${MYSQL_DATABASE} > /some/path/to/you/file/backup_nextcloud.sql  Notes :  Si les tables de la base sont des tables MylSAM (MySQL 3.23 \u00e0 MySQL 5.5), il est pr\u00e9f\u00e9rable d'utiliser l'utilitaire  mysqlhotcopy .  Docker  Dans le cas d'utilisation de la base dans un conteneur Docker ( /!\\ chose \u00e0 ne jamais faire dans un environnement de prod ), la commande peut \u00eatre ex\u00e9cut\u00e9e de l'ext\u00e9rieur du conteneur de cette mani\u00e8re :   docker exec some-mariadb sh -c 'exec mysqldump --all-databases -uroot -p\"$MYSQL_ROOT_PASSWORD\"' > /some/path/on/your/host/all-databases.sql",
            "title": "Effectuer un dump sur une base MariaDB"
        },
        {
            "location": "/wiki/DatabaseManagement/#postgres",
            "text": "Liens :   Doc postgres backup SQL  Doc postgres restore SQL  Doc sur l'outils  pg_dump  Doc postgres backup syst\u00e8me  Doc postgres backup \u00e0 chaud  Bonus : doc sur la migration  Pour aller plus loin  : pg_basebackup pour les backup de cluster",
            "title": "Postgres"
        },
        {
            "location": "/wiki/DatabaseManagement/#dump",
            "text": "Tout comme pour MariaDB, un utilitaire peut \u00eatre utilis\u00e9 :  pg_dump . Il permet la sauvegarde rapide et simple de bases de donn\u00e9es.  Utilisation   pg_dump dbname > backupfile.out  [1]  pg_dump -Ft dbname > backupfile.tar  [2]   Options :   -Ft  permet la compression en fichier .tar   La sortie standard de  pg_dump  se fait dans la sortie standard, une redirection de flux est n\u00e9cessaire.  Exemple d'utilisation : \nPour la sauvegarde de la base postgresql utilis\u00e9e avec la plate forme Gitlab : pg_dump --username=gitlab -Ft gitlabhq_production > backup.tar  Docker  Dans le cas d'utilisation de la base dans un conteneur Docker ( /!\\ chose \u00e0 ne jamais faire dans un environnement de prod ), la commande peut \u00eatre ex\u00e9cut\u00e9e de l'ext\u00e9rieur du conteneur de cette mani\u00e8re :   docker exec some_postgres bash -c 'pg_dump --username=gitlab -Ft gitlabhq_production' > backup.tar",
            "title": "Dump"
        },
        {
            "location": "/wiki/DatabaseManagement/#restauration-sql",
            "text": "Plusieurs solutions sont possibles selon le backup effectu\u00e9 :   [1] :  psql -d dbname -f backupfile.out  [2] :  pg_restore -C newDbName backupfile.tar      pg_restore -C  cr\u00e9er une nouvelle base, se connecte \u00e0 cette base et la peuple des donn\u00e9es du fichier de backup.",
            "title": "Restauration SQL"
        },
        {
            "location": "/wiki/DatabaseManagement/#backup-fichier-backup-a-froid",
            "text": "Cette strat\u00e9gie consiste en la sauvegarde des fichiers utilis\u00e9s par PostgreSQL pour enregistrer les donn\u00e9es. Pour cela, il suffit d'utiliser GNU tar pour compresser les fichiers du dossier contenant les donn\u00e9es de la base (dans notre cas  /var/lib/postgresql ).  Cependant, il y a deux restrictions \u00e0 cette m\u00e9thode :   Le serveur doit \u00eatre arr\u00eat\u00e9 pour obtenir une sauvegarde utilisable. Il en va de m\u00eame pour la restauration.  La sauvegarde et la restauration doivent \u00eatre totales.   Docker  Si la base de donn\u00e9e tourne dans un container Docker ayant un volume li\u00e9 sur l'host, il suffit de stopper le container, d'archiver les fichiers du volume et de rallumer le container.",
            "title": "Backup fichier / Backup \u00e0 froid"
        },
        {
            "location": "/wiki/DatabaseManagement/#restauration-dun-backup-a-froid",
            "text": "Docker  Arr\u00eatez le container, remplacer les fichiers du volume par ceux de la sauvegarde, rallumez le container.",
            "title": "Restauration d'un backup \u00e0 froid"
        },
        {
            "location": "/wiki/DatabaseManagement/#backup-a-chaud",
            "text": "Tout d'abord assurez-vous que l'archivage WAL est activ\u00e9 et fonctionnel.  Le backup \u00e0 chaud n\u00e9cessite de locker les donn\u00e9es pour \u00e9viter leur modifitcation le temps de la sauvegarde. Pour cela, il faut pr\u00e9venir le serveur de l'ex\u00e9cution de la sauvegarde gr\u00e2ce \u00e0 commande SQL :  SELECT pg_start_backup('label');  o\u00f9 label est toute cha\u00eene de caract\u00e8re utilis\u00e9e pour identifier de fa\u00e7on unique l'op\u00e9ration de sauvegarde. Cette commande cr\u00e9e un fichier  backup_label  contenant des informations sur la sauvegarde.  \u00c0 partir de l\u00e0, il est possible d'utiliser  tar  ou  cpio  afin de sauvegarder les fichiers.  Une fois la sauvegarde fini, pr\u00e9venez le serveur avec la commande  SELECT pg_stop_backup(); .  Une fois que les fichiers des segments WAL utilis\u00e9s lors de la sauvegarde sont archiv\u00e9s de la m\u00eame fa\u00e7on qu'une partie de l'activit\u00e9 normale de sauvegarde de la base de donn\u00e9es, vous avez termin\u00e9.",
            "title": "Backup \u00e0 chaud"
        },
        {
            "location": "/wiki/DatabaseManagement/#restauration-dune-sauvegarde-a-chaud",
            "text": "Arr\u00eatez le postmaster s'il est en cours d'ex\u00e9cution.  Si vous avez de la place pour le faire, copiez le r\u00e9pertoire entier des donn\u00e9es du groupe et tout tablespace dans un emplacement temporaire au cas o\u00f9 vous en auriez besoin plus tard. Notez que cette pr\u00e9caution demandera que vous ayez assez de place libre sur votre syst\u00e8me pour contenir deux copies de votre base de donn\u00e9es existante. Si vous n'avez pas assez de place, vous devez au moins copier le contenu du sous-r\u00e9pertoire pg_xlog du r\u00e9pertoire des donn\u00e9es car il pourrait contenir des journaux qui n'ont pas \u00e9t\u00e9 archiv\u00e9s avant l'arr\u00eat du serveur.  Effacez tous les fichier et sous-r\u00e9pertoires existants sous le r\u00e9pertoire des donn\u00e9es du groupe et sous les r\u00e9pertoires racines des tablespaces que vous utilisez.  Restaurez les fichiers de la base de donn\u00e9es \u00e0 partir de votre sauvegarde. Faites attention \u00e0 ce qu'ils soient restaur\u00e9s avec le bon propri\u00e9taire (l'utilisateur syst\u00e8me de la base de donn\u00e9es, et non pas root !) et avec les bons droits. Si vous utilisez les espaces logiques, vous v\u00e9rifirez que les liens symboliques dans pg_tblspc/ ont \u00e9t\u00e9 correctement restaur\u00e9s.  Supprimez tout fichier pr\u00e9sent dans pg_xlog/ ; ils proviennent de la sauvegarde et sont du coup probablement obsol\u00e8tes. Si vous n'avez pas archiv\u00e9 pg_xlog/ du tout, alors re-cr\u00e9ez ce r\u00e9pertoire ainsi que le sous-r\u00e9pertoire pg_xlog/archive_status/.  Si vous aviez des fichiers segments WAL non archiv\u00e9s que vous avez sauvegard\u00e9 dans l'\u00e9tape 2, copiez-les dans pg_xlog/ (il est mieux de les copier, pas de les d\u00e9placer, car vous aurez toujours les fichiers non modifi\u00e9s si un probl\u00e8me survient et que vous devez recommencer).  Cr\u00e9ez un fichier de commandes de r\u00e9cup\u00e9ration recovery.conf dans le r\u00e9pertoire des donn\u00e9es du groupe (voir Configuration de la r\u00e9cup\u00e9ration). De plus, vous pourriez vouloir modifier temporairement pg_hba.conf pour emp\u00eacher les utilisateurs ordinaires de se connecter tant que vous n'\u00eates pas certain que la r\u00e9cup\u00e9ration a r\u00e9ussi.  Lancez le postmaster. Le postmaster se trouvera en mode r\u00e9cup\u00e9ration et commencera la lecture des fichiers WAL archiv\u00e9s dont il a besoin. \u00c0 la fin du processus de r\u00e9cup\u00e9ration, le postmaster renommera recovery.conf en recovery.done (pour emp\u00eacher de retourner accidentellement en mode de r\u00e9cup\u00e9ration dans le cas d'un arr\u00eat brutal un peu plus tard), puis commencera les op\u00e9rations normales de la base de donn\u00e9es.  Inspectez le contenu de la base de donn\u00e9es pour vous assurer que vous avez r\u00e9cup\u00e9r\u00e9 ce que vous vouliez. Sinon, retournez \u00e0 l'\u00e9tape 1. Si tout va bien, laissez vos utilisateurs venir en restaurant le fichier pg_hba.conf \u00e0 son \u00e9tat normal.",
            "title": "Restauration d'une sauvegarde \u00e0 chaud"
        },
        {
            "location": "/wiki/DatabaseManagement/#mongodb",
            "text": "Liens :   Backup & restore tools for mongoDB  MongoDC backups",
            "title": "MongoDB"
        },
        {
            "location": "/wiki/DatabaseManagement/#lutilitaire-mongodump",
            "text": "L'utilitaire  mongodump  permet la sauvegarde binaire d'une base de donn\u00e9e dans un fichier BSON. Il est tr\u00e8s utile pour effectuer des backups de petits d\u00e9ploiements. Cependant, il n\u00e9cessite le parcours des index des tables et peut donc ralentir l'utilisation de la base par les applications.  Utilisation   mongodump --out dump_dir/  permet de faire un dump binaire de la base dans le dossier  dump_dir  mongorestore dump_dir/  permet la restauration de la base \u00e0 partir du dossier  dump_dir   Docker  Pour lancer un dump dans le container, il suffit de lancer :  docker exec some_mogodb bash -c 'mongodump --out /path/to/dump/dir'  N\u00e9anmoins, pour r\u00e9cup\u00e9rer le r\u00e9sultat, il est bon de compresser le dossier et de le mettre dans le volume partag\u00e9 :  docker exec some_mogodb bash -c 'mongodump | tar -cvf /path/to/shared/volume/file.tar'",
            "title": "L'utilitaire mongodump"
        },
        {
            "location": "/wiki/DatabaseManagement/#le-snapshot-du-filesystem",
            "text": "Liens :   Snapshot de filesytems   La sauvegarde par snapshot consiste \u00e0 prendre un snapshot \u00e0 un instant t des fichiers de la base de donn\u00e9es. Ceci n'est pas une op\u00e9ration sp\u00e9cifique \u00e0 MongoDB mais \u00e0 l'OS. Les m\u00e9caniques du process d\u00e9pendent alors du systeme de stockage. Par exemple, sur Linux, il est possible d'utiliser LVM (Logical Volume Manager).  Pour avoir un snapshot convenable de la base MongoDB, il faut que la journalisation soit activ\u00e9e et que le journal des logs se trouvent dans le m\u00eame volume logique que les autres fichiers de donn\u00e9es. Sans cela, il n'est pas assur\u00e9 que le snapshot soit consistent et valide.  Utilisation   Cr\u00e9ation d'un snapshot :  $ lvcreate --size 100M --snapshot --name mdb-snap01 /dev/vg0/mongodb  Archivage du snapshot :  $ umount /dev/vg0/mdb-snap01; dd if=/dev/vg0/mdb-snap01 | gzip > mdb-snap01.gz  Restoration du snapshot :   lvcreate --size 1G --name mdb-new vg0\ngzip -d -c mdb-snap01.gz | dd of=/dev/vg0/mdb-new\nmount /dev/vg0/mdb-new /srv/mongodb",
            "title": "Le snapshot du filesystem"
        },
        {
            "location": "/minions/core/nginx/README/",
            "text": "Nginx & letsencrypt container documentation\n\uf618\n\n\nTutorial d'installation\n\n\nNginx\n\uf618\n\n\nNGINX is a free, open-source, high-performance HTTP server and reverse proxy, as well as an IMAP/POP3 proxy server. NGINX is known for its high performance, stability, rich feature set, simple configuration, and low resource consumption.\n - \nOfficial Nginx wiki site\n\n\nLors de la cr\u00e9ation de notre environnement de travail, la question s'est pos\u00e9e de comment avoir acc\u00e8s \u00e0 nos diff\u00e9rents outils via le m\u00eame nom de domaine. La r\u00e9ponse semblait \u00e9vidente : les sous-domaines.\n\n\nPour cela, nous pouvions les g\u00e9rer via l'interface de notre h\u00e9bergeur et de notre DNS, cependant, l'id\u00e9e est d'avoir une tool box se d\u00e9ployant automatiquement avec une configuration valide en ajoutant que le strict n\u00e9cessaire (voir aucune) action humaine suppl\u00e9mentaire. De plus, l'instanciation d'un container docker attribu une adresse IP al\u00e9atoire au container et les ports attribu\u00e9s peuvent diff\u00e9r\u00e9. Le but \u00e9tait de simplifier au maximum la redirection vers les outils contenus dans les conteneurs.\n\n\nNous avons donc d\u00e9cid\u00e9s d'utiliser un premier conteneur Docker afin de l'utiliser comme \nreverse proxy\n pour rediriger les appels sur les sous-domaines vers l'outil correspondant. Pour cela, Nginx semblait \u00eatre le plus utilis\u00e9 et le plus document\u00e9.\n\n\nD\u00e9ploiement de l'image Docker\n\uf618\n\n\nL'image docker Nginx utilis\u00e9e n'est pas l'officielle mais une image open sourc\u00e9e build\u00e9e \u00e0 partir de l'originale. Elle expose les ports 80 \u00e0 but d'acc\u00e8s web (c'est par l\u00e0 que passeront chacune des requ\u00eates HTTP effectu\u00e9es sur le serveur (domaine et sous domaines)); et le port 443 pour le protocole HTTPS(\u00a7 suivant).\n\n\nnginx-proxy:\n    restart: always\n    image: jwilder/nginx-proxy:${NGINX_VERSION}\n    ports:\n        - \"80:80\"\n        - \"443:443\"\n    container_name: nginx-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:ro\n        - ${VOLUME_STORAGE_ROOT}/${VHOST_DIR}:/etc/nginx/vhost.d\n        - /usr/share/nginx/html\n        - /var/run/docker.sock:/tmp/docker.sock:ro\n\n\n\n\nImage utilis\u00e9e :\n \nNginx\n\n\nVolumes :\n\n\nCette image n\u00e9cessite diff\u00e9rents volumes :\n\n \n/usr/share/nginx/html\n : le r\u00e9pertoire web de l'application\n\n \n/var/run/docker.sock\n : la socket docker permettant la d\u00e9tection de la cr\u00e9ation d'un conteneur et la g\u00e9n\u00e9ration du sous domaine.\n\n \n/docker/vhost.d\n : la liste des hosts dans le network docker\n\n \n/srv/docker/nginx/certs\n : la liste des certificats de validation de l'h\u00f4te\n\n\nUne fois ce container en place, il suffit alors de rajouter la variable d'environnement \nVIRTUAL_HOST\n dans chacun des containers qui devront \u00eatre accessibles par via un sous-domaine.\n\n\nExemple\n\n\ndocker run --name foo -e VIRTUAL_HOST=sousdomaine.domaine bar\n\n\n\n\nOn peut ainsi acc\u00e9der au container bar via l'adresse \nsousdomaine.domaine\n. C'est plus joli que \ndomaine:port\n.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.\n\n \nNGINX_VERSION\n : version de l'image docker utilis\u00e9e\n\n \nCERT_DIR\n : dossier utilis\u00e9 comme volume pour les certificats g\u00e9n\u00e9r\u00e9s par LetsEncrypt (cf la partie sur les SSL).\n\n \nVHOST_DIR\n : dossier utilis\u00e9 comme volume pour le dossier vhost.d (virtual hosts) du serveur Nginx. Ce dossier est amen\u00e9 \u00e0 contenir certaines configuration. Par exemple, le fichier de configuration pour une application Nextcloud afin de limiter la taille d'upload des fichiers.\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nSSL, certificats et LetsEncrypt\n\uf618\n\n\nSSL & certificats\n\uf618\n\n\nMalgr\u00e9 la configuration du reverse proxy Nginx, nous nous sommes confront\u00e9s \u00e0 un probl\u00e8me de taille : nos sous-domaines n'\u00e9taient pas atteignables via https. Or certains n\u00e9cessite absoluement ce protocole (Gitlab, Mattermost ...). Pour cela, il fallait trouver une solution d'authentification des sites web. L'auto certification n'\u00e9tait pas assez s\u00fbre et la plus part des certifications \u00e9taient payantes, ainsi la solution \u00e9taient d'utiliser un deuxi\u00e8me container Docker : LetsEncrypt.\n\n\nLetsEncrypt\n\uf618\n\n\nLet\u2019s Encrypt is a free, automated, and open Certificate Authority\n - \nLetsEncrypt official website\n\n\nLetsEncrypt est un organisme de certification gratuit et automatique. Exactement ce dont on avait besoin pour valider nos requ\u00eates s\u00e9curis\u00e9es \u00e0 nos containers : la certification se faisant \u00e0 la vol\u00e9e \u00e0 chaque d\u00e9claration de sous-domaine au pr\u00eat d'Nginx, il n'y aurait aucun probl\u00e8me lors de la d\u00e9claration d'un nouveau container.\n\n\nnginx-proxy-companion:\n    restart: always\n    image: alastaircoote/docker-letsencrypt-nginx-proxy-companion:${LETSENCRYPT_VERSION}\n    container_name: letsencrypt-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:rw\n        - /var/run/docker.sock:/var/run/docker.sock\n    volumes_from:\n        - nginx-proxy\n\n\n\n\nImage :\n \nLetsEncrypt\n\n\nVolumes :\n\n\nCette image n\u00e9cessite diff\u00e9rents volumes :\n\n \n/srv/docker/nginx/certs\n : le m\u00eame que pour Nginx, afin de permettre la communication des certificats\n\n \n/var/run/docker.sock\n : pour utiliser la socket Docker et automatiser la g\u00e9n\u00e9ration des certificats\n\n\nLe container LetsEncrypt est intimement li\u00e9 \u00e0 Nginx : il n\u00e9cessite l'acc\u00e8s aux m\u00eames volumes (pour y d\u00e9poser les certificats, entre autre). Pour g\u00e9n\u00e9rer un certificat pour un certain sous-domaine, il suffit de d\u00e9finir les variables d'environnement suivantes :\n\n \nLETSENCRYPT_HOST\n\n\n \nLETSENCRYPT_EMAIL\n\n\nExemple :\n\n\ndocker run --name foo -e LETSENCRYPT_HOST=sousdomaine.domaine -e LETSENCRYPT_EMAIL=domaine@contact.fr bar\n\n\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.\n\n \nLETSENCRYPT_VERSION\n : version de l'image docker utilis\u00e9e\n\n \nCERT_DIR\n : dossier utilis\u00e9 comme volume pour les certificats g\u00e9n\u00e9r\u00e9s par LetsEncrypt.\n\n \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nFonctionnement final\n\uf618\n\n\nAinsi, \u00e0 chaque d\u00e9claration d'un nouveau container docker n\u00e9cessitant une interface web, un sous-domaine est d\u00e9fini via les trois variables d'environnement d\u00e9finies dans le docker-compose de l'outil. La configuration Nginx est alors recharg\u00e9e \u00e0 l'int\u00e9rieur du docker (\nnginx -s reload\n), un certificat est g\u00e9n\u00e9r\u00e9 par LetsEncrypt et le container est accessible via son interface web.\n\n\nExemple :\n\n\ndocker run --name foo -e VIRTUAL_HOST=sousdomaine.domaine -e LETSENCRYPT_HOST=sousdomaine.domaine -e LETSENCRYPT_EMAIL=domaine@contact.fr bar\n\n\n\n\nDocker-compose final\n\n\nnginx-proxy:\n    restart: always\n    image: jwilder/nginx-proxy:${NGINX_VERSION}\n    ports:\n        - \"80:80\"\n        - \"443:443\"\n    container_name: nginx-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:ro\n        - ${VOLUME_STORAGE_ROOT}/${VHOST_DIR}:/etc/nginx/vhost.d\n        - /usr/share/nginx/html\n        - /var/run/docker.sock:/tmp/docker.sock:ro\n\nnginx-proxy-companion:\n    restart: always\n    image: jrcs/letsencrypt-nginx-proxy-companion:${LETSENCRYPT_VERSION}\n    container_name: letsencrypt-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:rw\n        - /var/run/docker.sock:/var/run/docker.sock\n    volumes_from:\n        - nginx-proxy",
            "title": "Nginx"
        },
        {
            "location": "/minions/core/nginx/README/#nginx-letsencrypt-container-documentation",
            "text": "Tutorial d'installation",
            "title": "Nginx &amp; letsencrypt container documentation"
        },
        {
            "location": "/minions/core/nginx/README/#nginx",
            "text": "NGINX is a free, open-source, high-performance HTTP server and reverse proxy, as well as an IMAP/POP3 proxy server. NGINX is known for its high performance, stability, rich feature set, simple configuration, and low resource consumption.  -  Official Nginx wiki site  Lors de la cr\u00e9ation de notre environnement de travail, la question s'est pos\u00e9e de comment avoir acc\u00e8s \u00e0 nos diff\u00e9rents outils via le m\u00eame nom de domaine. La r\u00e9ponse semblait \u00e9vidente : les sous-domaines.  Pour cela, nous pouvions les g\u00e9rer via l'interface de notre h\u00e9bergeur et de notre DNS, cependant, l'id\u00e9e est d'avoir une tool box se d\u00e9ployant automatiquement avec une configuration valide en ajoutant que le strict n\u00e9cessaire (voir aucune) action humaine suppl\u00e9mentaire. De plus, l'instanciation d'un container docker attribu une adresse IP al\u00e9atoire au container et les ports attribu\u00e9s peuvent diff\u00e9r\u00e9. Le but \u00e9tait de simplifier au maximum la redirection vers les outils contenus dans les conteneurs.  Nous avons donc d\u00e9cid\u00e9s d'utiliser un premier conteneur Docker afin de l'utiliser comme  reverse proxy  pour rediriger les appels sur les sous-domaines vers l'outil correspondant. Pour cela, Nginx semblait \u00eatre le plus utilis\u00e9 et le plus document\u00e9.",
            "title": "Nginx"
        },
        {
            "location": "/minions/core/nginx/README/#deploiement-de-limage-docker",
            "text": "L'image docker Nginx utilis\u00e9e n'est pas l'officielle mais une image open sourc\u00e9e build\u00e9e \u00e0 partir de l'originale. Elle expose les ports 80 \u00e0 but d'acc\u00e8s web (c'est par l\u00e0 que passeront chacune des requ\u00eates HTTP effectu\u00e9es sur le serveur (domaine et sous domaines)); et le port 443 pour le protocole HTTPS(\u00a7 suivant).  nginx-proxy:\n    restart: always\n    image: jwilder/nginx-proxy:${NGINX_VERSION}\n    ports:\n        - \"80:80\"\n        - \"443:443\"\n    container_name: nginx-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:ro\n        - ${VOLUME_STORAGE_ROOT}/${VHOST_DIR}:/etc/nginx/vhost.d\n        - /usr/share/nginx/html\n        - /var/run/docker.sock:/tmp/docker.sock:ro  Image utilis\u00e9e :   Nginx  Volumes :  Cette image n\u00e9cessite diff\u00e9rents volumes :   /usr/share/nginx/html  : le r\u00e9pertoire web de l'application   /var/run/docker.sock  : la socket docker permettant la d\u00e9tection de la cr\u00e9ation d'un conteneur et la g\u00e9n\u00e9ration du sous domaine.   /docker/vhost.d  : la liste des hosts dans le network docker   /srv/docker/nginx/certs  : la liste des certificats de validation de l'h\u00f4te  Une fois ce container en place, il suffit alors de rajouter la variable d'environnement  VIRTUAL_HOST  dans chacun des containers qui devront \u00eatre accessibles par via un sous-domaine.  Exemple  docker run --name foo -e VIRTUAL_HOST=sousdomaine.domaine bar  On peut ainsi acc\u00e9der au container bar via l'adresse  sousdomaine.domaine . C'est plus joli que  domaine:port .  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com ). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.   NGINX_VERSION  : version de l'image docker utilis\u00e9e   CERT_DIR  : dossier utilis\u00e9 comme volume pour les certificats g\u00e9n\u00e9r\u00e9s par LetsEncrypt (cf la partie sur les SSL).   VHOST_DIR  : dossier utilis\u00e9 comme volume pour le dossier vhost.d (virtual hosts) du serveur Nginx. Ce dossier est amen\u00e9 \u00e0 contenir certaines configuration. Par exemple, le fichier de configuration pour une application Nextcloud afin de limiter la taille d'upload des fichiers.\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "D\u00e9ploiement de l'image Docker"
        },
        {
            "location": "/minions/core/nginx/README/#ssl-certificats-et-letsencrypt",
            "text": "",
            "title": "SSL, certificats et LetsEncrypt"
        },
        {
            "location": "/minions/core/nginx/README/#ssl-certificats",
            "text": "Malgr\u00e9 la configuration du reverse proxy Nginx, nous nous sommes confront\u00e9s \u00e0 un probl\u00e8me de taille : nos sous-domaines n'\u00e9taient pas atteignables via https. Or certains n\u00e9cessite absoluement ce protocole (Gitlab, Mattermost ...). Pour cela, il fallait trouver une solution d'authentification des sites web. L'auto certification n'\u00e9tait pas assez s\u00fbre et la plus part des certifications \u00e9taient payantes, ainsi la solution \u00e9taient d'utiliser un deuxi\u00e8me container Docker : LetsEncrypt.",
            "title": "SSL &amp; certificats"
        },
        {
            "location": "/minions/core/nginx/README/#letsencrypt",
            "text": "Let\u2019s Encrypt is a free, automated, and open Certificate Authority  -  LetsEncrypt official website  LetsEncrypt est un organisme de certification gratuit et automatique. Exactement ce dont on avait besoin pour valider nos requ\u00eates s\u00e9curis\u00e9es \u00e0 nos containers : la certification se faisant \u00e0 la vol\u00e9e \u00e0 chaque d\u00e9claration de sous-domaine au pr\u00eat d'Nginx, il n'y aurait aucun probl\u00e8me lors de la d\u00e9claration d'un nouveau container.  nginx-proxy-companion:\n    restart: always\n    image: alastaircoote/docker-letsencrypt-nginx-proxy-companion:${LETSENCRYPT_VERSION}\n    container_name: letsencrypt-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:rw\n        - /var/run/docker.sock:/var/run/docker.sock\n    volumes_from:\n        - nginx-proxy  Image :   LetsEncrypt  Volumes :  Cette image n\u00e9cessite diff\u00e9rents volumes :   /srv/docker/nginx/certs  : le m\u00eame que pour Nginx, afin de permettre la communication des certificats   /var/run/docker.sock  : pour utiliser la socket Docker et automatiser la g\u00e9n\u00e9ration des certificats  Le container LetsEncrypt est intimement li\u00e9 \u00e0 Nginx : il n\u00e9cessite l'acc\u00e8s aux m\u00eames volumes (pour y d\u00e9poser les certificats, entre autre). Pour g\u00e9n\u00e9rer un certificat pour un certain sous-domaine, il suffit de d\u00e9finir les variables d'environnement suivantes :   LETSENCRYPT_HOST    LETSENCRYPT_EMAIL  Exemple :  docker run --name foo -e LETSENCRYPT_HOST=sousdomaine.domaine -e LETSENCRYPT_EMAIL=domaine@contact.fr bar  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com ). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.   LETSENCRYPT_VERSION  : version de l'image docker utilis\u00e9e   CERT_DIR  : dossier utilis\u00e9 comme volume pour les certificats g\u00e9n\u00e9r\u00e9s par LetsEncrypt.   VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "LetsEncrypt"
        },
        {
            "location": "/minions/core/nginx/README/#fonctionnement-final",
            "text": "Ainsi, \u00e0 chaque d\u00e9claration d'un nouveau container docker n\u00e9cessitant une interface web, un sous-domaine est d\u00e9fini via les trois variables d'environnement d\u00e9finies dans le docker-compose de l'outil. La configuration Nginx est alors recharg\u00e9e \u00e0 l'int\u00e9rieur du docker ( nginx -s reload ), un certificat est g\u00e9n\u00e9r\u00e9 par LetsEncrypt et le container est accessible via son interface web.  Exemple :  docker run --name foo -e VIRTUAL_HOST=sousdomaine.domaine -e LETSENCRYPT_HOST=sousdomaine.domaine -e LETSENCRYPT_EMAIL=domaine@contact.fr bar  Docker-compose final  nginx-proxy:\n    restart: always\n    image: jwilder/nginx-proxy:${NGINX_VERSION}\n    ports:\n        - \"80:80\"\n        - \"443:443\"\n    container_name: nginx-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:ro\n        - ${VOLUME_STORAGE_ROOT}/${VHOST_DIR}:/etc/nginx/vhost.d\n        - /usr/share/nginx/html\n        - /var/run/docker.sock:/tmp/docker.sock:ro\n\nnginx-proxy-companion:\n    restart: always\n    image: jrcs/letsencrypt-nginx-proxy-companion:${LETSENCRYPT_VERSION}\n    container_name: letsencrypt-${DOMAIN}\n    volumes:\n        - ${VOLUME_STORAGE_ROOT}/${CERT_DIR}:/etc/nginx/certs:rw\n        - /var/run/docker.sock:/var/run/docker.sock\n    volumes_from:\n        - nginx-proxy",
            "title": "Fonctionnement final"
        },
        {
            "location": "/minions/core/OpenLDAP/README/",
            "text": "Work in progress",
            "title": "OpenLDAP"
        },
        {
            "location": "/minions/core/registry/README/",
            "text": "Work in progress",
            "title": "Docker registry"
        },
        {
            "location": "/minions/etherpad/README/",
            "text": "Work in progress",
            "title": "Etherpad"
        },
        {
            "location": "/minions/ghost/README/",
            "text": "Ghost container documentation\n\uf618\n\n\nDocumentation du fichier \ndocker-compose.yml\n d'un conteneur pour site Ghost\n\n\nGhost est une plate-forme open source de blogging simple de prise en main. Elle comprend un \u00e9diteur markdown pour faciliter la r\u00e9daction d'article, l'int\u00e9gration d'images aux articles ...\n\n\nD\u00e9finition du conteneur\n\uf618\n\n\nghost:\n  image: ghost:${GHOST_VERSION}\n  container_name: ghost-${GHOST_SUBDOMAIN}-${DOMAIN}\n  ports:\n    - \"${GHOST_WEB_PORT}:2368\"\n  environment:\n    - VIRTUAL_HOST=${GHOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${GHOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${GHOST_SUBDOMAIN}@${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${GHOST_SUBDOMAIN}/blog:/var/lib/ghost/\n\n\n\n\nImage utilis\u00e9e :\n \nghost\n\n\nPort expos\u00e9 :\n\n\nLe port expos\u00e9 par d\u00e9faut est le 2368. Libre \u00e0 vous de le li\u00e9 \u00e0 un autre port de votre machine .\n\n\nEnvironnement :\n\n\nLes variables d'environnement utilis\u00e9es sont n\u00e9cessaires \u00e0 Nginx pour d\u00e9finir le sous domaine du blog.  Pour plus d'information, voir la \ndocumentation sur Nginx\n.\n\n\nVolume :\n\n\nLe volume utilis\u00e9e permet le stockage du contenu.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nGHOST_VERSION\n : version utilis\u00e9e de l'image docker\n\n \nGHOST_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nghost\n pour \nghost.example.com\n)\n\n \nGHOST_WEB_PORT\n : port de l'h\u00f4te utilis\u00e9 pour acc\u00e9der \u00e0 l'application\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Ghost"
        },
        {
            "location": "/minions/ghost/README/#ghost-container-documentation",
            "text": "Documentation du fichier  docker-compose.yml  d'un conteneur pour site Ghost  Ghost est une plate-forme open source de blogging simple de prise en main. Elle comprend un \u00e9diteur markdown pour faciliter la r\u00e9daction d'article, l'int\u00e9gration d'images aux articles ...",
            "title": "Ghost container documentation"
        },
        {
            "location": "/minions/ghost/README/#definition-du-conteneur",
            "text": "ghost:\n  image: ghost:${GHOST_VERSION}\n  container_name: ghost-${GHOST_SUBDOMAIN}-${DOMAIN}\n  ports:\n    - \"${GHOST_WEB_PORT}:2368\"\n  environment:\n    - VIRTUAL_HOST=${GHOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${GHOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${GHOST_SUBDOMAIN}@${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${GHOST_SUBDOMAIN}/blog:/var/lib/ghost/  Image utilis\u00e9e :   ghost  Port expos\u00e9 :  Le port expos\u00e9 par d\u00e9faut est le 2368. Libre \u00e0 vous de le li\u00e9 \u00e0 un autre port de votre machine .  Environnement :  Les variables d'environnement utilis\u00e9es sont n\u00e9cessaires \u00e0 Nginx pour d\u00e9finir le sous domaine du blog.  Pour plus d'information, voir la  documentation sur Nginx .  Volume :  Le volume utilis\u00e9e permet le stockage du contenu.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   GHOST_VERSION  : version utilis\u00e9e de l'image docker   GHOST_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  ghost  pour  ghost.example.com )   GHOST_WEB_PORT  : port de l'h\u00f4te utilis\u00e9 pour acc\u00e9der \u00e0 l'application\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "D\u00e9finition du conteneur"
        },
        {
            "location": "/minions/gitlab/README/",
            "text": "Gitlab container & Gitlab CI documentation\n\uf618\n\n\nDocumentation du fichier \ndocker-compose.yml\n de la solution Gitlab & GitlabCI\n\uf618\n\n\nLa cr\u00e9ation d'un syst\u00e8me d'int\u00e9gration continue gr\u00e2ce \u00e0 la solution \nGitlab\n n\u00e9cessite l'existance de deux instances diff\u00e9rentes :\n\n Une instance d'administration \nGitlab\n permettant la gestion des utilisateurs, la cr\u00e9ation et gestion de d\u00e9p\u00f4ts, donnant l'acc\u00e8s aux param\u00e8tres du serveur \nGit\n \u00e0 proprement parler.\n\n Une instance d'administration des ressources d'int\u00e9gration continue : \nGitlab CI\n. Cette instance ne poss\u00e8de pas d'interface utilisateur. Elle sert principalement \u00e0 d\u00e9finir et cr\u00e9er des \nrunners\n, des conteneurs pr\u00e9-configur\u00e9s pr\u00eat \u00e0 ex\u00e9cuter les t\u00e2ches d'int\u00e9gration.\nLes runners peuvent \u00eatre de plusieurs types mais nous utiliserons un conteneur \nDocker\n.\n\n\nD\u00e9finition des conteneurs\n\uf618\n\n\nGitlab\n\nLe service Gitlab n\u00e9cessite un serveur \nRedis\n et un base de donn\u00e9e \nMySQL\n ou \nPostgreSQL\n.\n\n\nGitlab CI\n\nPlus pr\u00e9cis\u00e9ment \ngitlab-runner\n est l'image officielle utilis\u00e9e dans notre architecture. Elle n'a pas besoin d'\u00eatre interfac\u00e9e \u00e0 un quelconque container et n'expose aucun port. Sa d\u00e9finition ne n\u00e9cessite qu'un volume.\n\nLa nouveaut\u00e9 est la n\u00e9cessit\u00e9 de li\u00e9 la socket de Docker au syst\u00e8me afin d'utiliser des dockers comme runner. \n\u00e0 approfondir\n\n\nBase de donn\u00e9es\n\uf618\n\n\npostgresql:\n  restart: always\n  image: sameersbn/postgresql:${GITLAB_POSTGRESQL_VERSION}\n  container_name: postgresql-${GITLAB_SUBDOMAIN}-${DOMAIN}\n  environment:\n    - DB_USER=${POSTGRES_USER}\n    - DB_PASS=${POSTGRES_PASSWORD}\n    - DB_NAME=gitlabhq_production\n    - DB_EXTENSION=pg_trgm\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${GITLAB_DB_DATA_DIR}:/var/lib/postgresql:Z\n\n\n\n\nImage utilis\u00e9e :\n \nsameersbn/postgresql\n\n\nEnvironnement :\n  \n\n\nLa base PostgreSQL n\u00e9cessite la d\u00e9finition des param\u00e8tres suivants :\n\n \nDB_NAME\n : nom de la base de donn\u00e9e utilis\u00e9e\n\n \nDB_USER\n : l'utilisateur utilis\u00e9 par Gitlab\n\n \nDB_PASS\n : le mot de passe de l'utilisateur\n\n \nDB_EXTENSION\n : liste des extensions PostgreSQL \u00e0 activer sur la base (\nPostgre packages\n)\n\n\nVolumes :\n Cette image n\u00e9cessite un volume de stockage li\u00e9 \u00e0 son dossier \n/var/lib/postgresql\n.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.\n\n \nGITLAB_POSTGRESQL_VERSION\n : version de l'image docker de PostgreSQL utilis\u00e9e\n\n \nGITLAB_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \ngitlab\n pour \ngitlab.exemple.com\n)\n\n \nPOSTGRES_USER\n : nom d'utilisateur li\u00e9 \u00e0 Gitlab\n\n \nPOSTGRES_PASSWORD\n : mot de passe associ\u00e9 \u00e0 l'utilisateur Gitlab.\n\n \nGITLAB_DB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour stocker les donn\u00e9es de la base.\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nServeur Redis\n\uf618\n\n\nredis:\n  restart: always\n  image: sameersbn/redis:${GITLAB_REDIS_VERSION}\n  container_name: redis-${GITLAB_SUBDOMAIN}-${DOMAIN}\n  volumes:\n  - ${VOLUME_STORAGE_ROOT}/${GITLAB_REDIS_DATA_DIR}:/var/lib/redis\n\n\n\n\nImage utilis\u00e9e :\n \nsameersbn/redis\n\n\nEnvironnement :\n\n\nCe conteneur ne n\u00e9cessite pas de variable d'environnement puisqu'on utilise le processus de \nlink\n de docker pour le li\u00e9 \u00e0 notre instance Gitlab.\n\n\nVolumes :\n Cette image n\u00e9cessite un volume de stockage li\u00e9 \u00e0 son dossier \n/var/lib/redis\n.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.\n\n \nGITLAB_REDIS_VERSION\n : version de l'image docker de Redis utilis\u00e9e\n\n \nGITLAB_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \ngitlab\n pour \ngitlab.exemple.com\n)\n\n \nGITLAB_REDIS_DATA_DIR\n : dossier utilis\u00e9 comme volume pour stocker les donn\u00e9es du serveur Redis.\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nServeur Gitlab\n\uf618\n\n\ngitlab:\n  restart: always\n  image: sameersbn/gitlab:${GITLAB_VERSION}\n  container_name: ${GITLAB_SUBDOMAIN}-${DOMAIN}\n  links:\n    - postgresql\n    - redis\n  ports:\n    - \"${GITLAB_SSH_PORT}:22\"\n    - \"5000:5000\"\n    - \"${GITLAB_WEB_PORT}:80\"\n    - \"${GITLAB_HTTPS_PORT}:443\"\n  volumes:\n  - ${VOLUME_STORAGE_ROOT}/${GITLAB_DATA_DIR}:/home/git/data:Z\n  - ${VOLUME_STORAGE_ROOT}/${GITLAB_LOGS_DIR}:/var/log/gitlab\n  - ${VOLUME_STORAGE_ROOT}${CERT_DIR}:/certs\n  environment:\n  - DEBUG=false\n\n  - DB_ADAPTER=postgresql\n  - DB_HOST=postgresql\n  - DB_PORT=5432\n  - DB_USER=${POSTGRES_USER}\n  - DB_PASS=${POSTGRES_PASSWORD}\n  - DB_NAME=gitlabhq_production\n\n  - REDIS_HOST=redis\n  - REDIS_PORT=6379\n\n  - TZ=Europe/Paris\n  - GITLAB_TIMEZONE=Paris\n\n  - GITLAB_HTTPS=true\n  - SSL_SELF_SIGNED=false\n  - SSL_KEY_PATH=/certs/${GITLAB_SUBDOMAIN}.${DOMAIN}.key\n  - SSL_CERTIFICATE_PATH=/certs/${GITLAB_SUBDOMAIN}.${DOMAIN}.crt\n  - SSL_DHPARAM_PATH=/certs/${GITLAB_SUBDOMAIN}.${DOMAIN}.dhparam.pem\n  - HSTS MAXAGE=0\n  - NGINX_HSTS_ENABLED=false\n\n  - GITLAB_HOST=${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - GITLAB_PORT=${GITLAB_HTTPS_PORT}\n  - GITLAB_SSH_PORT=${GITLAB_SSH_PORT}\n  - GITLAB_SECRETS_SECRET_KEY_BASE=cdJXTPqnwcmtrqcHqhz7xqHmCkFngMgRgq7wVTspVXMgq7qKvVrn47HnmxTtX4zK\n  - GITLAB_SECRETS_DB_KEY_BASE=JPrx3ngpbwmLknsLqRKdMWvwwb9MLvLfkCcCfWpxVbwfJMJcvkHRKgTt9HpfmdgX\n  - GITLAB_SECRETS_OTP_KEY_BASE=9hbKtnNLmxCKdxMwTLKdnd4wWzRCTjzMs7dnhpNHLCxdrhwHhj3fPVtJ7KfdFLtf\n\n  - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true\n  - GITLAB_NOTIFY_PUSHER=false\n\n  - GITLAB_EMAIL=notifications@example.com\n  - GITLAB_EMAIL_REPLY_TO=noreply@example.com\n  - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com\n\n  - GITLAB_BACKUP_SCHEDULE=daily\n  - GITLAB_BACKUP_TIME=01:00\n\n  - SMTP_ENABLED=true\n  - SMTP_DOMAIN=www.gmail.com\n  - SMTP_HOST=smtp.gmail.com\n  - SMTP_PORT=587\n  - SMTP_USER=puzle.project@gmail.com\n  - SMTP_PASS=iK5.z/mlsO4!oik\n  - SMTP_STARTTLS=true\n  - SMTP_AUTHENTICATION=login\n\n  - IMAP_ENABLED=false\n  - IMAP_HOST=imap.gmail.com\n  - IMAP_PORT=993\n  - IMAP_USER=mailer@example.com\n  - IMAP_PASS=password\n  - IMAP_SSL=true\n  - IMAP_STARTTLS=false\n\n  - VIRTUAL_HOST=${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - VIRTUAL_PORT=${GITLAB_HTTPS_PORT}\n  - VIRTUAL_PROTO=https\n  - LETSENCRYPT_HOST=${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - LETSENCRYPT_EMAIL=puzle.project@gmail.com\n\n  - GITLAB_REGISTRY_ENABLED=true\n  - GITLAB_REGISTRY_HOST=registry.${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - GITLAB_REGISTRY_PORT=5000\n  - GITLAB_REGISTRY_API_URL=https://registry.${GITLAB_SUBDOMAIN}.${DOMAIN}:5000\n  - GITLAB_REGISTRY_ISSUER=gitlab-issuer\n  - GITLAB_REGISTRY_KEY_PATH=/certs/registry.${GITLAB_SUBDOMAIN}.${DOMAIN}.key\n  - SSL_REGISTRY_KEY_PATH=/certs/registry.${GITLAB_SUBDOMAIN}.${DOMAIN}.key\n  - SSL_REGISTRY_CERT_PATH=/certs/registry.${GITLAB_SUBDOMAIN}.${DOMAIN}.crt\n\n\n\n\nImage utilis\u00e9e :\n \nsameersbn/gitlab\n\n\nEnvironnement :\n  \n\n\nL'instance Gitlab peut \u00eatre fortement param\u00e8trable de part sa longue liste de variable d'environnement (\nvoir la liste compl\u00e8te\n).\nVoici certaines valeurs explicit\u00e9es :\n\n \nGITLAB_SECRETS_SECRET_KEY_BASE\n : cha\u00eene de 64 caract\u00e8res minimum utilis\u00e9e pour le cryptage des sessions\n\n\n \nGITLAB_SECRETS_OTP_KEY_BASE\n : cha\u00eene de 64 charact\u00e8res minimum utilis\u00e9e pour les op\u00e9rations li\u00e9es au processus d'OPT (\nOne time password\n).\n\n \nGITLAB_SECRETS_DB_KEY_BASE\n : cha\u00eene de 32 charact\u00e8res minimum utilis\u00e9e pour le cryptage li\u00e9 \u00e0 la base de donn\u00e9es.\n\n \nGITLAB_PORT\n : num\u00e9ro du port li\u00e9 au port 80 de l'instance\n* \nGITLAB_SSH_PORT\n : num\u00e9ro du port li\u00e9 au port 22 de l'instance\n\n\nLes variables d'environnement \nVIRTUAL_HOST\n, \nLETSENCRYPT_HOST\n et \nLETSENCRYPT_EMAIL\n sont n\u00e9cessaires \u00e0 la d\u00e9finition d'un sous domaine. Pour plus d'information, voir la \ndocumentation sur Nginx\n\n\nVolumes :\n\nCette image n\u00e9cessite un volume de stockage li\u00e9 \u00e0 son dossier \n/home/git/data\n.\n\n\nVariables :\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.\n\n \nGITLAB_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \ngitlab\n pour \ngitlab.exemple.com\n)\n\n \nGITLAB_VERSION\n : version de l'image docker de Gitlab utilis\u00e9e\n\n \nGITLAB_WEB_PORT\n : port utilis\u00e9 par Gitlab pour un acc\u00e8s via HTTP\n\n \nGITLAB_HTTPS_PORT\n : port utilis\u00e9 pour un acc\u00e8s via HTTPS\n\n \nGITLAB_SSH_PORT\n : port utilis\u00e9 pour les acc\u00e8s SSH\n\n \nGITLAB_LOGS_DIR\n : dossier utilis\u00e9 comme volume pour stocker les logs de l'application\n\n \nGITLAB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour stocker les logs de l'application\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nServeur de CI\n\uf618\n\n\ngitlab-runner:\n  image: gitlab/gitlab-runner:${GITLAB_CI_VERSION}\n  container_name: CI-${GITLAB_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n    - /srv/gitlab-runner/config:/etc/gitlab-runner\n\n\n\n\nImage utilis\u00e9e :\n \ngitlab/gitlab-runner\n\n\nVolumes :\n\nAfin de pouvoir utiliser des images Docker en tant que runner, cette image doit poss\u00e9der un lien entre la socket Docker de l'h\u00e9bergeur et celle du conteneur. Ensuite, la config de l'instance est charg\u00e9e dans le r\u00e9pertoire \n/etc/gitlab-runner\n.\n\n\nCr\u00e9ation d'un projet Gitlab\n\uf618\n\n\nLa cr\u00e9ation d'un projet se fait simplement via l'interface web de l'instance \nGitlab\n. Si le projet contient des tests unitaires, fonctionnels ou tout simplement s'il on veut tester la compilation du projet, il est possible d'ajouter un \nrunner\n \u00e0 ce projet. Pour cela, il faut se rendre dans l'onglet de param\u00e8tre et s\u00e9lectionner \"\nCI/CD pipelines\n\". A partir de cette interface, il est possible d'associer un runner au projet.\n\n\nUtilisation d'un \nregistry\n\uf618\n\n\nTo document\n\n\nCr\u00e9ation d'un runner\n\uf618\n\n\nOn se penchera ici sur la cr\u00e9ation d'un runner utilisant docker comme g\u00e9n\u00e9rateur d'environnement.\n\n\nLa cr\u00e9ation d'un runner est simple : il suffit d'ex\u00e9cuter la commande suivante \u00e0 l'int\u00e9rieur du conteneur Docker :\n\n\ngitlab-ci-multi-runner register\n# Ou bien, si l'on se trouve \u00e0 l'ext\u00e9rieur de l'instance\ndocker exec -it gitlab-ci-multi-runner register\n\n\n\n\nDes questions de personnalisation seront pos\u00e9es :\n\n L'URL du coordinateur Gitlab, i.e. l'instance administrative de Gitlab. Ex : \nhttps://gitlab.example.com/ci\n - \nNe pas oublier la partie : \nhttps\n\n\n Le token de l'instance Gitlab : il peut \u00eatre r\u00e9cup\u00e9r\u00e9 dans la partie \nrunners\n de l'instance administrative.\n\n Une courte description du runner.\n\n L'executeur du runner : \ndocker\n our \ndocker-ssh\n selon votre choix.\n* L'image Docker utilis\u00e9e par le runner.\n\n\nApr\u00e8s cela, le runner est cr\u00e9\u00e9 et disponible dans la liste des runners de l'instance Gitlab. Si des projets \u00e9taient en attente d'un runner, il sera d\u00e9j\u00e0 associ\u00e9 \u00e0 ceux-ci.\n\n\nConfiguration du CI\n\uf618\n\n\nLe conteneur est pr\u00eat \u00e0 \u00eatre utilis\u00e9. Il suffit maintenant de lui d\u00e9crire les actions \u00e0 r\u00e9aliser \u00e0 chaque \ncommit\n re\u00e7u. Gitlab n\u00e9cessite pour cela la cr\u00e9ation d'un fichier \n.gitlab-ci.yml\n. Ce fichier permet de d\u00e9finir les diff\u00e9rents jobs d\u00e9finissant les diff\u00e9rentes actions \u00e0 effectuer : les tests, builder la documentation, builder le projet et d\u00e9ployer. Ces jobs auront des d\u00e9pendances, seront effectu\u00e9s ou non dans certains cas etc.\n\n\nExemple de fichier :\n\n\nstages:\n  - test\n  - docker\n  - deploy\n\nvariables:\n  SERVER_NAME: lesmowdoo.com\n  REGISTRY_URL: registry.$SERVER_NAME\n  DOCKER_IMAGE_NAME: summoner/portal\n  SUMMONER_MINIONS_DIR: ~/Summoner/minions/\n\ntest:\n  image: alpine:3.5\n  stage: test\n  variables:\n      GIT_SUBMODULE_STRATEGY: normal\n  script:\n    - apk update && apk add openssl\n    - wget https://github.com/spf13/hugo/releases/download/v0.18.1/hugo_0.18.1_Linux-64bit.tar.gz\n    - echo \"e8ba723c508e87912970f132534c64dc  hugo_0.18.1_Linux-64bit.tar.gz\" | md5sum -c\n    - tar xf hugo_0.18.1_Linux-64bit.tar.gz --strip-components=1 && mv hugo_0.18.1_linux_amd64 hugo && cp ./hugo /usr/bin\n    - hugo version\n    - hugo --theme=\"slate\"\n    - ls public/\n    - cat public/index.html\n  artifacts:\n    paths:\n      - public/\n\ndocker-build:\n  stage: docker\n  variables:\n    GIT_SUBMODULE_STRATEGY: none\n  tags: \n    - docker-build\n  services:\n    - docker:dind\n  script:\n    - ls public/\n    - cat public/index.html\n    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $REGISTRY_URL\n    - docker build -t $REGISTRY_URL/$DOCKER_IMAGE_NAME .\n    - docker push $REGISTRY_URL/$DOCKER_IMAGE_NAME:latest\n  dependencies:\n    - test\n  only:\n    - master\n\ndeploy:\n  stage: deploy\n  tags:\n    - debian\n    - wheezy\n  script:\n    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'\n    - eval $(ssh-agent -s)\n    - ssh-add <(echo \"$SSH_PRIVATE_KEY\")\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts'\n    - ssh root@$SERVER_NAME mkdir -p $SUMMONER_MINIONS_DIR/portal\n    - scp docker-compose.yml root@$SERVER_NAME:$SUMMONER_MINIONS_DIR/portal\n    - ssh root@$SERVER_NAME 'bash -s' < deploy.sh\n  only:\n    - master\n\n\n\n\nDescription\n\uf618\n\n\n\n\nStages\n\n\n\n\nD\u00e9fini les diff\u00e9rentes \u00e9tapes de l'int\u00e9gration. Ceux-ci sont libres de cr\u00e9ation.",
            "title": "Gitlab"
        },
        {
            "location": "/minions/gitlab/README/#gitlab-container-gitlab-ci-documentation",
            "text": "",
            "title": "Gitlab container &amp; Gitlab CI documentation"
        },
        {
            "location": "/minions/gitlab/README/#documentation-du-fichier-docker-composeyml-de-la-solution-gitlab-gitlabci",
            "text": "La cr\u00e9ation d'un syst\u00e8me d'int\u00e9gration continue gr\u00e2ce \u00e0 la solution  Gitlab  n\u00e9cessite l'existance de deux instances diff\u00e9rentes :  Une instance d'administration  Gitlab  permettant la gestion des utilisateurs, la cr\u00e9ation et gestion de d\u00e9p\u00f4ts, donnant l'acc\u00e8s aux param\u00e8tres du serveur  Git  \u00e0 proprement parler.  Une instance d'administration des ressources d'int\u00e9gration continue :  Gitlab CI . Cette instance ne poss\u00e8de pas d'interface utilisateur. Elle sert principalement \u00e0 d\u00e9finir et cr\u00e9er des  runners , des conteneurs pr\u00e9-configur\u00e9s pr\u00eat \u00e0 ex\u00e9cuter les t\u00e2ches d'int\u00e9gration.\nLes runners peuvent \u00eatre de plusieurs types mais nous utiliserons un conteneur  Docker .",
            "title": "Documentation du fichier docker-compose.yml de la solution Gitlab &amp; GitlabCI"
        },
        {
            "location": "/minions/gitlab/README/#definition-des-conteneurs",
            "text": "Gitlab \nLe service Gitlab n\u00e9cessite un serveur  Redis  et un base de donn\u00e9e  MySQL  ou  PostgreSQL .  Gitlab CI \nPlus pr\u00e9cis\u00e9ment  gitlab-runner  est l'image officielle utilis\u00e9e dans notre architecture. Elle n'a pas besoin d'\u00eatre interfac\u00e9e \u00e0 un quelconque container et n'expose aucun port. Sa d\u00e9finition ne n\u00e9cessite qu'un volume. \nLa nouveaut\u00e9 est la n\u00e9cessit\u00e9 de li\u00e9 la socket de Docker au syst\u00e8me afin d'utiliser des dockers comme runner.  \u00e0 approfondir",
            "title": "D\u00e9finition des conteneurs"
        },
        {
            "location": "/minions/gitlab/README/#base-de-donnees",
            "text": "postgresql:\n  restart: always\n  image: sameersbn/postgresql:${GITLAB_POSTGRESQL_VERSION}\n  container_name: postgresql-${GITLAB_SUBDOMAIN}-${DOMAIN}\n  environment:\n    - DB_USER=${POSTGRES_USER}\n    - DB_PASS=${POSTGRES_PASSWORD}\n    - DB_NAME=gitlabhq_production\n    - DB_EXTENSION=pg_trgm\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${GITLAB_DB_DATA_DIR}:/var/lib/postgresql:Z  Image utilis\u00e9e :   sameersbn/postgresql  Environnement :     La base PostgreSQL n\u00e9cessite la d\u00e9finition des param\u00e8tres suivants :   DB_NAME  : nom de la base de donn\u00e9e utilis\u00e9e   DB_USER  : l'utilisateur utilis\u00e9 par Gitlab   DB_PASS  : le mot de passe de l'utilisateur   DB_EXTENSION  : liste des extensions PostgreSQL \u00e0 activer sur la base ( Postgre packages )  Volumes :  Cette image n\u00e9cessite un volume de stockage li\u00e9 \u00e0 son dossier  /var/lib/postgresql .  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com ). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.   GITLAB_POSTGRESQL_VERSION  : version de l'image docker de PostgreSQL utilis\u00e9e   GITLAB_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  gitlab  pour  gitlab.exemple.com )   POSTGRES_USER  : nom d'utilisateur li\u00e9 \u00e0 Gitlab   POSTGRES_PASSWORD  : mot de passe associ\u00e9 \u00e0 l'utilisateur Gitlab.   GITLAB_DB_DATA_DIR  : dossier utilis\u00e9 comme volume pour stocker les donn\u00e9es de la base.\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Base de donn\u00e9es"
        },
        {
            "location": "/minions/gitlab/README/#serveur-redis",
            "text": "redis:\n  restart: always\n  image: sameersbn/redis:${GITLAB_REDIS_VERSION}\n  container_name: redis-${GITLAB_SUBDOMAIN}-${DOMAIN}\n  volumes:\n  - ${VOLUME_STORAGE_ROOT}/${GITLAB_REDIS_DATA_DIR}:/var/lib/redis  Image utilis\u00e9e :   sameersbn/redis  Environnement :  Ce conteneur ne n\u00e9cessite pas de variable d'environnement puisqu'on utilise le processus de  link  de docker pour le li\u00e9 \u00e0 notre instance Gitlab.  Volumes :  Cette image n\u00e9cessite un volume de stockage li\u00e9 \u00e0 son dossier  /var/lib/redis .  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com ). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.   GITLAB_REDIS_VERSION  : version de l'image docker de Redis utilis\u00e9e   GITLAB_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  gitlab  pour  gitlab.exemple.com )   GITLAB_REDIS_DATA_DIR  : dossier utilis\u00e9 comme volume pour stocker les donn\u00e9es du serveur Redis.\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Serveur Redis"
        },
        {
            "location": "/minions/gitlab/README/#serveur-gitlab",
            "text": "gitlab:\n  restart: always\n  image: sameersbn/gitlab:${GITLAB_VERSION}\n  container_name: ${GITLAB_SUBDOMAIN}-${DOMAIN}\n  links:\n    - postgresql\n    - redis\n  ports:\n    - \"${GITLAB_SSH_PORT}:22\"\n    - \"5000:5000\"\n    - \"${GITLAB_WEB_PORT}:80\"\n    - \"${GITLAB_HTTPS_PORT}:443\"\n  volumes:\n  - ${VOLUME_STORAGE_ROOT}/${GITLAB_DATA_DIR}:/home/git/data:Z\n  - ${VOLUME_STORAGE_ROOT}/${GITLAB_LOGS_DIR}:/var/log/gitlab\n  - ${VOLUME_STORAGE_ROOT}${CERT_DIR}:/certs\n  environment:\n  - DEBUG=false\n\n  - DB_ADAPTER=postgresql\n  - DB_HOST=postgresql\n  - DB_PORT=5432\n  - DB_USER=${POSTGRES_USER}\n  - DB_PASS=${POSTGRES_PASSWORD}\n  - DB_NAME=gitlabhq_production\n\n  - REDIS_HOST=redis\n  - REDIS_PORT=6379\n\n  - TZ=Europe/Paris\n  - GITLAB_TIMEZONE=Paris\n\n  - GITLAB_HTTPS=true\n  - SSL_SELF_SIGNED=false\n  - SSL_KEY_PATH=/certs/${GITLAB_SUBDOMAIN}.${DOMAIN}.key\n  - SSL_CERTIFICATE_PATH=/certs/${GITLAB_SUBDOMAIN}.${DOMAIN}.crt\n  - SSL_DHPARAM_PATH=/certs/${GITLAB_SUBDOMAIN}.${DOMAIN}.dhparam.pem\n  - HSTS MAXAGE=0\n  - NGINX_HSTS_ENABLED=false\n\n  - GITLAB_HOST=${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - GITLAB_PORT=${GITLAB_HTTPS_PORT}\n  - GITLAB_SSH_PORT=${GITLAB_SSH_PORT}\n  - GITLAB_SECRETS_SECRET_KEY_BASE=cdJXTPqnwcmtrqcHqhz7xqHmCkFngMgRgq7wVTspVXMgq7qKvVrn47HnmxTtX4zK\n  - GITLAB_SECRETS_DB_KEY_BASE=JPrx3ngpbwmLknsLqRKdMWvwwb9MLvLfkCcCfWpxVbwfJMJcvkHRKgTt9HpfmdgX\n  - GITLAB_SECRETS_OTP_KEY_BASE=9hbKtnNLmxCKdxMwTLKdnd4wWzRCTjzMs7dnhpNHLCxdrhwHhj3fPVtJ7KfdFLtf\n\n  - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true\n  - GITLAB_NOTIFY_PUSHER=false\n\n  - GITLAB_EMAIL=notifications@example.com\n  - GITLAB_EMAIL_REPLY_TO=noreply@example.com\n  - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com\n\n  - GITLAB_BACKUP_SCHEDULE=daily\n  - GITLAB_BACKUP_TIME=01:00\n\n  - SMTP_ENABLED=true\n  - SMTP_DOMAIN=www.gmail.com\n  - SMTP_HOST=smtp.gmail.com\n  - SMTP_PORT=587\n  - SMTP_USER=puzle.project@gmail.com\n  - SMTP_PASS=iK5.z/mlsO4!oik\n  - SMTP_STARTTLS=true\n  - SMTP_AUTHENTICATION=login\n\n  - IMAP_ENABLED=false\n  - IMAP_HOST=imap.gmail.com\n  - IMAP_PORT=993\n  - IMAP_USER=mailer@example.com\n  - IMAP_PASS=password\n  - IMAP_SSL=true\n  - IMAP_STARTTLS=false\n\n  - VIRTUAL_HOST=${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - VIRTUAL_PORT=${GITLAB_HTTPS_PORT}\n  - VIRTUAL_PROTO=https\n  - LETSENCRYPT_HOST=${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - LETSENCRYPT_EMAIL=puzle.project@gmail.com\n\n  - GITLAB_REGISTRY_ENABLED=true\n  - GITLAB_REGISTRY_HOST=registry.${GITLAB_SUBDOMAIN}.${DOMAIN}\n  - GITLAB_REGISTRY_PORT=5000\n  - GITLAB_REGISTRY_API_URL=https://registry.${GITLAB_SUBDOMAIN}.${DOMAIN}:5000\n  - GITLAB_REGISTRY_ISSUER=gitlab-issuer\n  - GITLAB_REGISTRY_KEY_PATH=/certs/registry.${GITLAB_SUBDOMAIN}.${DOMAIN}.key\n  - SSL_REGISTRY_KEY_PATH=/certs/registry.${GITLAB_SUBDOMAIN}.${DOMAIN}.key\n  - SSL_REGISTRY_CERT_PATH=/certs/registry.${GITLAB_SUBDOMAIN}.${DOMAIN}.crt  Image utilis\u00e9e :   sameersbn/gitlab  Environnement :     L'instance Gitlab peut \u00eatre fortement param\u00e8trable de part sa longue liste de variable d'environnement ( voir la liste compl\u00e8te ).\nVoici certaines valeurs explicit\u00e9es :   GITLAB_SECRETS_SECRET_KEY_BASE  : cha\u00eene de 64 caract\u00e8res minimum utilis\u00e9e pour le cryptage des sessions    GITLAB_SECRETS_OTP_KEY_BASE  : cha\u00eene de 64 charact\u00e8res minimum utilis\u00e9e pour les op\u00e9rations li\u00e9es au processus d'OPT ( One time password ).   GITLAB_SECRETS_DB_KEY_BASE  : cha\u00eene de 32 charact\u00e8res minimum utilis\u00e9e pour le cryptage li\u00e9 \u00e0 la base de donn\u00e9es.   GITLAB_PORT  : num\u00e9ro du port li\u00e9 au port 80 de l'instance\n*  GITLAB_SSH_PORT  : num\u00e9ro du port li\u00e9 au port 22 de l'instance  Les variables d'environnement  VIRTUAL_HOST ,  LETSENCRYPT_HOST  et  LETSENCRYPT_EMAIL  sont n\u00e9cessaires \u00e0 la d\u00e9finition d'un sous domaine. Pour plus d'information, voir la  documentation sur Nginx  Volumes : \nCette image n\u00e9cessite un volume de stockage li\u00e9 \u00e0 son dossier  /home/git/data .  Variables :  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com ). Ne sert ici qu'\u00e0 nommer convenablement le conteneur.   GITLAB_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  gitlab  pour  gitlab.exemple.com )   GITLAB_VERSION  : version de l'image docker de Gitlab utilis\u00e9e   GITLAB_WEB_PORT  : port utilis\u00e9 par Gitlab pour un acc\u00e8s via HTTP   GITLAB_HTTPS_PORT  : port utilis\u00e9 pour un acc\u00e8s via HTTPS   GITLAB_SSH_PORT  : port utilis\u00e9 pour les acc\u00e8s SSH   GITLAB_LOGS_DIR  : dossier utilis\u00e9 comme volume pour stocker les logs de l'application   GITLAB_DATA_DIR  : dossier utilis\u00e9 comme volume pour stocker les logs de l'application\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Serveur Gitlab"
        },
        {
            "location": "/minions/gitlab/README/#serveur-de-ci",
            "text": "gitlab-runner:\n  image: gitlab/gitlab-runner:${GITLAB_CI_VERSION}\n  container_name: CI-${GITLAB_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n    - /srv/gitlab-runner/config:/etc/gitlab-runner  Image utilis\u00e9e :   gitlab/gitlab-runner  Volumes : \nAfin de pouvoir utiliser des images Docker en tant que runner, cette image doit poss\u00e9der un lien entre la socket Docker de l'h\u00e9bergeur et celle du conteneur. Ensuite, la config de l'instance est charg\u00e9e dans le r\u00e9pertoire  /etc/gitlab-runner .",
            "title": "Serveur de CI"
        },
        {
            "location": "/minions/gitlab/README/#creation-dun-projet-gitlab",
            "text": "La cr\u00e9ation d'un projet se fait simplement via l'interface web de l'instance  Gitlab . Si le projet contient des tests unitaires, fonctionnels ou tout simplement s'il on veut tester la compilation du projet, il est possible d'ajouter un  runner  \u00e0 ce projet. Pour cela, il faut se rendre dans l'onglet de param\u00e8tre et s\u00e9lectionner \" CI/CD pipelines \". A partir de cette interface, il est possible d'associer un runner au projet.",
            "title": "Cr\u00e9ation d'un projet Gitlab"
        },
        {
            "location": "/minions/gitlab/README/#utilisation-dun-registry",
            "text": "To document",
            "title": "Utilisation d'un registry"
        },
        {
            "location": "/minions/gitlab/README/#creation-dun-runner",
            "text": "On se penchera ici sur la cr\u00e9ation d'un runner utilisant docker comme g\u00e9n\u00e9rateur d'environnement.  La cr\u00e9ation d'un runner est simple : il suffit d'ex\u00e9cuter la commande suivante \u00e0 l'int\u00e9rieur du conteneur Docker :  gitlab-ci-multi-runner register\n# Ou bien, si l'on se trouve \u00e0 l'ext\u00e9rieur de l'instance\ndocker exec -it gitlab-ci-multi-runner register  Des questions de personnalisation seront pos\u00e9es :  L'URL du coordinateur Gitlab, i.e. l'instance administrative de Gitlab. Ex :  https://gitlab.example.com/ci  -  Ne pas oublier la partie :  https   Le token de l'instance Gitlab : il peut \u00eatre r\u00e9cup\u00e9r\u00e9 dans la partie  runners  de l'instance administrative.  Une courte description du runner.  L'executeur du runner :  docker  our  docker-ssh  selon votre choix.\n* L'image Docker utilis\u00e9e par le runner.  Apr\u00e8s cela, le runner est cr\u00e9\u00e9 et disponible dans la liste des runners de l'instance Gitlab. Si des projets \u00e9taient en attente d'un runner, il sera d\u00e9j\u00e0 associ\u00e9 \u00e0 ceux-ci.",
            "title": "Cr\u00e9ation d'un runner"
        },
        {
            "location": "/minions/gitlab/README/#configuration-du-ci",
            "text": "Le conteneur est pr\u00eat \u00e0 \u00eatre utilis\u00e9. Il suffit maintenant de lui d\u00e9crire les actions \u00e0 r\u00e9aliser \u00e0 chaque  commit  re\u00e7u. Gitlab n\u00e9cessite pour cela la cr\u00e9ation d'un fichier  .gitlab-ci.yml . Ce fichier permet de d\u00e9finir les diff\u00e9rents jobs d\u00e9finissant les diff\u00e9rentes actions \u00e0 effectuer : les tests, builder la documentation, builder le projet et d\u00e9ployer. Ces jobs auront des d\u00e9pendances, seront effectu\u00e9s ou non dans certains cas etc.  Exemple de fichier :  stages:\n  - test\n  - docker\n  - deploy\n\nvariables:\n  SERVER_NAME: lesmowdoo.com\n  REGISTRY_URL: registry.$SERVER_NAME\n  DOCKER_IMAGE_NAME: summoner/portal\n  SUMMONER_MINIONS_DIR: ~/Summoner/minions/\n\ntest:\n  image: alpine:3.5\n  stage: test\n  variables:\n      GIT_SUBMODULE_STRATEGY: normal\n  script:\n    - apk update && apk add openssl\n    - wget https://github.com/spf13/hugo/releases/download/v0.18.1/hugo_0.18.1_Linux-64bit.tar.gz\n    - echo \"e8ba723c508e87912970f132534c64dc  hugo_0.18.1_Linux-64bit.tar.gz\" | md5sum -c\n    - tar xf hugo_0.18.1_Linux-64bit.tar.gz --strip-components=1 && mv hugo_0.18.1_linux_amd64 hugo && cp ./hugo /usr/bin\n    - hugo version\n    - hugo --theme=\"slate\"\n    - ls public/\n    - cat public/index.html\n  artifacts:\n    paths:\n      - public/\n\ndocker-build:\n  stage: docker\n  variables:\n    GIT_SUBMODULE_STRATEGY: none\n  tags: \n    - docker-build\n  services:\n    - docker:dind\n  script:\n    - ls public/\n    - cat public/index.html\n    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $REGISTRY_URL\n    - docker build -t $REGISTRY_URL/$DOCKER_IMAGE_NAME .\n    - docker push $REGISTRY_URL/$DOCKER_IMAGE_NAME:latest\n  dependencies:\n    - test\n  only:\n    - master\n\ndeploy:\n  stage: deploy\n  tags:\n    - debian\n    - wheezy\n  script:\n    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'\n    - eval $(ssh-agent -s)\n    - ssh-add <(echo \"$SSH_PRIVATE_KEY\")\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts'\n    - ssh root@$SERVER_NAME mkdir -p $SUMMONER_MINIONS_DIR/portal\n    - scp docker-compose.yml root@$SERVER_NAME:$SUMMONER_MINIONS_DIR/portal\n    - ssh root@$SERVER_NAME 'bash -s' < deploy.sh\n  only:\n    - master",
            "title": "Configuration du CI"
        },
        {
            "location": "/minions/gitlab/README/#description",
            "text": "Stages   D\u00e9fini les diff\u00e9rentes \u00e9tapes de l'int\u00e9gration. Ceux-ci sont libres de cr\u00e9ation.",
            "title": "Description"
        },
        {
            "location": "/minions/mailserver/README/",
            "text": "Mail server as a docker\n\uf618\n\n\ntest : \ndig +short TXT @ns17.ovh.net. lesmowdoo.com.",
            "title": "Serveur mail"
        },
        {
            "location": "/minions/mailserver/README/#mail-server-as-a-docker",
            "text": "test : \ndig +short TXT @ns17.ovh.net. lesmowdoo.com.",
            "title": "Mail server as a docker"
        },
        {
            "location": "/minions/mattermost/README/",
            "text": "Conteneur Mattermost\n\uf618\n\n\nDocumentation du fichier \ndocker-compose.yml\n d'un conteneur pour une instance Mattermost\n\n\nMattermost est une solution Slack-like de chat multi channel opensource. A la diff\u00e9rence de \nSlack\n, aucune application bureau n'est disponible. Cependant, l'application mobile est gratuite sur Google Store et App Store.\n\n\nBase de donn\u00e9es\n\uf618\n\n\nmysql:\n  restart: always\n  image: mysql:${MATTERMOST_MYSQL_VERSION}\n  environment:\n    - MYSQL_USER=${MYSQL_USER}\n    - MYSQL_PASSWORD=${MYSQL_PASSWORD}\n    - MYSQL_DATABASE=${MYSQL_DATABASE}\n    - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${MATTERMOST_DB_DATA_DIR}:/var/lib/mysql\n  container_name: mysql-${MATTERMOST_SUBDOMAIN}-${DOMAIN}\n\n\n\n\nImage utilis\u00e9e :\n \nMySQL\n\n\nEnvironnement :\n\n\nLes variables suivantes sont n\u00e9cessaires \u00e0 l'utilisation de la base :\n\n \nMYSQL_USER\n : nom de l'utilisateur associ\u00e9 \u00e0 mattermost\n\n \nMYSQL_PASSWORD\n : mot de passe de l'utilisateur mattermost\n\n \nMYSQL_DATABASE\n : nom de la base associ\u00e9e \u00e0 mattermost\n\n \nMYSQL_ROOT_PASSWORD\n : mot de passe de l'utilisateur root de la base\n\n\nVolumes :\n\n\nLe volume utilis\u00e9 ici permet la r\u00e9cup\u00e9ration des donn\u00e9es de la base.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nMATTERMOST_MYSQL_VERSION\n : version de l'image docker de MySQL utilis\u00e9e\n\n \nMATTERMOST_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nmattermost\n pour \nmattermost.example.com\n)\n\n \nMATTERMOST_DB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e\n\n \nMYSQL_PASSWORD\n : mot de passe de l'utilisateur associ\u00e9 \u00e0 mattermost\n\n \nMYSQL_ROOT_PASSWORD\n : mot de passe associ\u00e9 \u00e0 l'utilisateur root de la base de donn\u00e9es\n\n \nMYSQL_DB_NAME\n : nom de la base de donn\u00e9e associ\u00e9e \u00e0 Mattermost\n\n \nMYSQL_USER\n : nom de l'utilisateur associ\u00e9 \u00e0 Mattermost\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nInstance Mattermost\n\uf618\n\n\nmattermost:\n  restart: always\n  image: jasl8r/mattermost:${MATTERMOST_VERSION}\n  links:\n    - mysql:mysql\n  ports:\n    - \"${MATTERMOST_WEB_PORT}:80\"\n  environment:\n    - MATTERMOST_SECRET_KEY=d9wVPX3x7h9wWkVVcwwTJ4knhfLkr3Mzf4CNL3WgdTTpJvjqWK3VzTp7pHHhjcqs\n    - MATTERMOST_LINK_SALT=NPgCWVg4sK4c9dgTjrPtCWjkzMvHFtqzNLvXTJdKt4gWtzLXzzvjJ4Kjqs3fFkRv\n    - MATTERMOST_RESET_SALT=7frPRCsdxs3zKLhKKWFkt3ksprzWFTkw3vnhcHXMp3d4zjkKjkPVMXsFxWRzf3qn\n    - MATTERMOST_INVITE_SALT=7frPRCsdxs3zKLhKKWFkt3ksprzWFTkw3vnhcHXMp3d4zjkKjkPVMXsFxWRzf3qn\n    - VIRTUAL_HOST=${MATTERMOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${MATTERMOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${MATTERMOST_SUBDOMAIN}.${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${MATTERMOST_DATA_DIR}:/opt/mattermost/data\n  container_name: ${MATTERMOST_SUBDOMAIN}-${DOMAIN}\n\n\n\n\nImage utilis\u00e9e :\n\u00a0\nMattermost par Jasl8r\n\n\nEnvironnement :\n\n\nIci, les variables d'environnement utilis\u00e9es sont un peu sp\u00e9ciales :\n\n \nMATTERMOST_SECRET_KEY\n : sel des champs sensibles de la base de donn\u00e9es.\n\n \nMATTERMOST_LINK_SALT\n : sel utilis\u00e9 pour les liens publiques.\n\n \nMATTERMOST_RESET_SALT\n : sel utilis\u00e9 pour signer les mails de remise \u00e0 z\u00e9ro des mots de passe.\n\n \nMATTERMOST_INVITE_SALT\n : sel utilis\u00e9 pour signer les mails d'invitations.\n\n\nVolumes :\n\n\nLe volume utilis\u00e9 permet de r\u00e9cup\u00e9rer les donn\u00e9es li\u00e9es \u00e0 l'application.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nMATTERMOST_VERSION\n : version de l'image docker de Mattermost utilis\u00e9e\n\n \nMATTERMOST_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nmattermost\n pour \nmattermost.example.com\n)\n\n \nMATTERMOST_DATA_DIR\n : dossier utilis\u00e9 comme volume pour les donn\u00e9es de Mattermost\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Mattermost"
        },
        {
            "location": "/minions/mattermost/README/#conteneur-mattermost",
            "text": "Documentation du fichier  docker-compose.yml  d'un conteneur pour une instance Mattermost  Mattermost est une solution Slack-like de chat multi channel opensource. A la diff\u00e9rence de  Slack , aucune application bureau n'est disponible. Cependant, l'application mobile est gratuite sur Google Store et App Store.",
            "title": "Conteneur Mattermost"
        },
        {
            "location": "/minions/mattermost/README/#base-de-donnees",
            "text": "mysql:\n  restart: always\n  image: mysql:${MATTERMOST_MYSQL_VERSION}\n  environment:\n    - MYSQL_USER=${MYSQL_USER}\n    - MYSQL_PASSWORD=${MYSQL_PASSWORD}\n    - MYSQL_DATABASE=${MYSQL_DATABASE}\n    - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${MATTERMOST_DB_DATA_DIR}:/var/lib/mysql\n  container_name: mysql-${MATTERMOST_SUBDOMAIN}-${DOMAIN}  Image utilis\u00e9e :   MySQL  Environnement :  Les variables suivantes sont n\u00e9cessaires \u00e0 l'utilisation de la base :   MYSQL_USER  : nom de l'utilisateur associ\u00e9 \u00e0 mattermost   MYSQL_PASSWORD  : mot de passe de l'utilisateur mattermost   MYSQL_DATABASE  : nom de la base associ\u00e9e \u00e0 mattermost   MYSQL_ROOT_PASSWORD  : mot de passe de l'utilisateur root de la base  Volumes :  Le volume utilis\u00e9 ici permet la r\u00e9cup\u00e9ration des donn\u00e9es de la base.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   MATTERMOST_MYSQL_VERSION  : version de l'image docker de MySQL utilis\u00e9e   MATTERMOST_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  mattermost  pour  mattermost.example.com )   MATTERMOST_DB_DATA_DIR  : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e   MYSQL_PASSWORD  : mot de passe de l'utilisateur associ\u00e9 \u00e0 mattermost   MYSQL_ROOT_PASSWORD  : mot de passe associ\u00e9 \u00e0 l'utilisateur root de la base de donn\u00e9es   MYSQL_DB_NAME  : nom de la base de donn\u00e9e associ\u00e9e \u00e0 Mattermost   MYSQL_USER  : nom de l'utilisateur associ\u00e9 \u00e0 Mattermost\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Base de donn\u00e9es"
        },
        {
            "location": "/minions/mattermost/README/#instance-mattermost",
            "text": "mattermost:\n  restart: always\n  image: jasl8r/mattermost:${MATTERMOST_VERSION}\n  links:\n    - mysql:mysql\n  ports:\n    - \"${MATTERMOST_WEB_PORT}:80\"\n  environment:\n    - MATTERMOST_SECRET_KEY=d9wVPX3x7h9wWkVVcwwTJ4knhfLkr3Mzf4CNL3WgdTTpJvjqWK3VzTp7pHHhjcqs\n    - MATTERMOST_LINK_SALT=NPgCWVg4sK4c9dgTjrPtCWjkzMvHFtqzNLvXTJdKt4gWtzLXzzvjJ4Kjqs3fFkRv\n    - MATTERMOST_RESET_SALT=7frPRCsdxs3zKLhKKWFkt3ksprzWFTkw3vnhcHXMp3d4zjkKjkPVMXsFxWRzf3qn\n    - MATTERMOST_INVITE_SALT=7frPRCsdxs3zKLhKKWFkt3ksprzWFTkw3vnhcHXMp3d4zjkKjkPVMXsFxWRzf3qn\n    - VIRTUAL_HOST=${MATTERMOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${MATTERMOST_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${MATTERMOST_SUBDOMAIN}.${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${MATTERMOST_DATA_DIR}:/opt/mattermost/data\n  container_name: ${MATTERMOST_SUBDOMAIN}-${DOMAIN}  Image utilis\u00e9e : \u00a0 Mattermost par Jasl8r  Environnement :  Ici, les variables d'environnement utilis\u00e9es sont un peu sp\u00e9ciales :   MATTERMOST_SECRET_KEY  : sel des champs sensibles de la base de donn\u00e9es.   MATTERMOST_LINK_SALT  : sel utilis\u00e9 pour les liens publiques.   MATTERMOST_RESET_SALT  : sel utilis\u00e9 pour signer les mails de remise \u00e0 z\u00e9ro des mots de passe.   MATTERMOST_INVITE_SALT  : sel utilis\u00e9 pour signer les mails d'invitations.  Volumes :  Le volume utilis\u00e9 permet de r\u00e9cup\u00e9rer les donn\u00e9es li\u00e9es \u00e0 l'application.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   MATTERMOST_VERSION  : version de l'image docker de Mattermost utilis\u00e9e   MATTERMOST_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  mattermost  pour  mattermost.example.com )   MATTERMOST_DATA_DIR  : dossier utilis\u00e9 comme volume pour les donn\u00e9es de Mattermost\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Instance Mattermost"
        },
        {
            "location": "/minions/nextcloud/README/",
            "text": "Container Nextcloud\n\uf618\n\n\nDocumentation du fichier \ndocker-compose.yml\n d'un conteneur pour une instance Nextcloud.\n\n\nNextcloud est une solution de stockage en \nCloud\n opensource poss\u00e9dant une interface web, un client bureau et une application mobile gratuite.\n\n\nBase de donn\u00e9es\n\uf618\n\n\nnextcloud-db:\n  image: mariadb:${NEXTCLOUD_MARIADB_VERSION}\n  container_name: mariadb-${NEXTCLOUD_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_DB_DATA_DIR}:/var/lib/mysql\n  environment:\n    - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n    - MYSQL_DATABASE=${MYSQL_DB_NAME}\n    - MYSQL_USER=${MYSQL_USER}\n    - MYSQL_PASSWORD=${MYSQL_PASSWORD}\n\n\n\n\nImage utilis\u00e9e :\n \nmariadb\n\n\nEnvironnement :\n\n\nLa base MariaDB n\u00e9cessite la d\u00e9finition des variables suivantes :\n\n \nMYSQL_ROOT_PASSWORD\n : mot de passe de l'utilisateur root\n\n \nMYSQL_DATABASE\n : nom de la base de donn\u00e9es associ\u00e9e \u00e0 Nextcloud\n\n \nMYSQL_USER\n : utilisateur associ\u00e9 \u00e0 Nextcloud\n\n \nMYSQL_PASSWORD\n : mot de passe de l'utilisateur\n\n\nVolumes :\n Pour conserver les donn\u00e9es de la base de donn\u00e9es, un volume li\u00e9 au dossier \nvar/lib/mysql\n peut \u00eatre cr\u00e9\u00e9.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nNEXTCLOUD_MARIADB_VERSION\n : version de l'image docker de MariaDB utilis\u00e9e\n\n \nNEXTCLOUD_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nnextcloud\n pour \nnextcloud.example.com\n)\n\n \nNEXTCLOUD_DB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e\n\n \nMYSQL_PASSWORD\n : mot de passe de l'utilisateur associ\u00e9 \u00e0 nextcloud\n\n \nMYSQL_ROOT_PASSWORD\n : mot de passe associ\u00e9 \u00e0 l'utilisateur root de la base de donn\u00e9es\n\n \nMYSQL_DB_NAME\n : nom de la base de donn\u00e9e associ\u00e9e \u00e0 Nextcloud\n\n \nMYSQL_USER\n : nom de l'utilisateur associ\u00e9 \u00e0 Nextcloud\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nInstance Nextcloud\n\uf618\n\n\nnextcloud:\n  image: wonderfall/nextcloud:${NEXTCLOUD_VERSION}\n  container_name: ${NEXTCLOUD_SUBDOMAIN}-${DOMAIN}\n  links:\n    - nextcloud-db:nextcloud-db\n  environment:\n    - UID=1000\n    - GID=1000\n    - UPLOAD_MAX_SIZE=10G\n    - APC_SHM_SIZE=128M\n    - OPCACHE_MEM_SIZE=128\n    - REDIS_MAX_MEMORY=64mb\n    - CRON_PERIOD=15m\n    - TZ=Europe/Berlin\n    - ADMIN_USER=${NEXTCLOUD_ADMIN_USER}\n    - ADMIN_PASSWORD=${NEXTCLOUD_ADMIN_PASSWORD}\n    - DB_TYPE=mysql\n    - DB_NAME=${MYSQL_DB_NAME}\n    - DB_USER=${MYSQL_USER}\n    - DB_PASSWORD=${MYSQL_PASSWORD}\n    - DB_HOST=nextcloud-db\n    - VIRTUAL_HOST=${NEXTCLOUD_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${NEXTCLOUD_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=contact@${NEXTCLOUD_SUBDOMAIN}.${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_DATA_DIR}:/data\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_CONFIG_DIR}:/config\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_APPS_DIR}:/apps2\n  ports:\n    - \"${NEXTCLOUD_WEB_PORT}:8888\"\n\n\n\n\nImage utilis\u00e9e :\n \nNextcloud\n\n\nEnvironnement :\n\n\nLes variables d'environnement sont nombreuses :\n\n \nUID\n : nextcloud user id\n\n \nGID\n : nextcloud group id\n\n \nUPLOAD_MAX_SIZE\n : taille maximale d'upload de fichiers (d\u00e9fini les valeurs dans les fichiers \n.htaccess\n et \nphp.ini\n (?))\n\n \nAPC_SHM_SIZE\n : quantit\u00e9 de m\u00e9moire partag\u00e9e allou\u00e9e \u00e0 APC (Alternative Php Cache).\n\n \nOPCACHE_MEM_SIZE\n : taille de la m\u00e9moire cache utilis\u00e9e par OPCACHE.\n\n \nREDIS_MAX_MEMORY\n : taille maximale du buffer du serveur Redis\n\n \nCRON_PERIOD\n : p\u00e9riode d'activation du cron unix.\n\n \nTZ\n : time zone d\u00e9finissant la langue et l'heure serveur.\n\n \nADMIN_USER\n : utilisateur poss\u00e9dant les droits administrateurs\n\n \nADMIN_PASSWORD\n : mot de passe du compte administrateur\n\n \nDB_TYPE\n : type de la base de donn\u00e9es li\u00e9e \u00e0 l'instance\n\n \nDB_NAME\n : nom de la base de donn\u00e9es\n\n \nDB_USER\n : utilisateur nextcloud de la base de donn\u00e9es\n\n \nDB_PASSWORD\n : mot de passe de l'utilisateur nextcloud\n* \nDB_HOST\n : adresse de la base de donn\u00e9es. Correspond \u00e0 l'adresse du serveur distant ou au nom du service docker.\n\n\nVolumes :\n\n\nLa configuration de l'instance Nextcloud se trouve dans le dossier \n/config\n; les fichiers h\u00e9berg\u00e9s dans le dossier \n/data\n et les donn\u00e9es relatives \u00e0 l'application dans \n/apps2\n.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nNEXTCLOUD_VERSION\n : version de l'image docker de Nextcloud utilis\u00e9e\n\n \nNEXTCLOUD_MARIADB_VERSION\n : version de l'image docker de MariaDB utilis\u00e9e\n\n \nNEXTCLOUD_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nnextcloud\n pour \nnextcloud.example.com\n)\n\n \nNEXTCLOUD_WEB_PORT\n : port de l'h\u00f4te utilis\u00e9 pour acc\u00e9der \u00e0 l'application\n\n \nNEXTCLOUD_ADMIN_USER\n : nom de l'utilisateur admin nextcloud\n\n \nNEXTCLOUD_ADMIN_PASSWORD\n : mot de passe de l'utilisateur admin\n\n \nNEXTCLOUD_DB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e\n\n \nNEXTCLOUD_DATA_DIR\n : dossier utilis\u00e9 comme volume pour les donn\u00e9es de Nextcloud\n\n \nNEXTCLOUD_CONFIG_DIR\n : dossier utilis\u00e9 comme volume pour les fichiers de configuration de Nextcloud\n\n \nNEXTCLOUD_APPS_DIR\n : dossier utilis\u00e9 comme volume pour les donn\u00e9es li\u00e9es \u00e0 l'application Nextcloud\n\n \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Nextcloud"
        },
        {
            "location": "/minions/nextcloud/README/#container-nextcloud",
            "text": "Documentation du fichier  docker-compose.yml  d'un conteneur pour une instance Nextcloud.  Nextcloud est une solution de stockage en  Cloud  opensource poss\u00e9dant une interface web, un client bureau et une application mobile gratuite.",
            "title": "Container Nextcloud"
        },
        {
            "location": "/minions/nextcloud/README/#base-de-donnees",
            "text": "nextcloud-db:\n  image: mariadb:${NEXTCLOUD_MARIADB_VERSION}\n  container_name: mariadb-${NEXTCLOUD_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_DB_DATA_DIR}:/var/lib/mysql\n  environment:\n    - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n    - MYSQL_DATABASE=${MYSQL_DB_NAME}\n    - MYSQL_USER=${MYSQL_USER}\n    - MYSQL_PASSWORD=${MYSQL_PASSWORD}  Image utilis\u00e9e :   mariadb  Environnement :  La base MariaDB n\u00e9cessite la d\u00e9finition des variables suivantes :   MYSQL_ROOT_PASSWORD  : mot de passe de l'utilisateur root   MYSQL_DATABASE  : nom de la base de donn\u00e9es associ\u00e9e \u00e0 Nextcloud   MYSQL_USER  : utilisateur associ\u00e9 \u00e0 Nextcloud   MYSQL_PASSWORD  : mot de passe de l'utilisateur  Volumes :  Pour conserver les donn\u00e9es de la base de donn\u00e9es, un volume li\u00e9 au dossier  var/lib/mysql  peut \u00eatre cr\u00e9\u00e9.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   NEXTCLOUD_MARIADB_VERSION  : version de l'image docker de MariaDB utilis\u00e9e   NEXTCLOUD_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  nextcloud  pour  nextcloud.example.com )   NEXTCLOUD_DB_DATA_DIR  : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e   MYSQL_PASSWORD  : mot de passe de l'utilisateur associ\u00e9 \u00e0 nextcloud   MYSQL_ROOT_PASSWORD  : mot de passe associ\u00e9 \u00e0 l'utilisateur root de la base de donn\u00e9es   MYSQL_DB_NAME  : nom de la base de donn\u00e9e associ\u00e9e \u00e0 Nextcloud   MYSQL_USER  : nom de l'utilisateur associ\u00e9 \u00e0 Nextcloud\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Base de donn\u00e9es"
        },
        {
            "location": "/minions/nextcloud/README/#instance-nextcloud",
            "text": "nextcloud:\n  image: wonderfall/nextcloud:${NEXTCLOUD_VERSION}\n  container_name: ${NEXTCLOUD_SUBDOMAIN}-${DOMAIN}\n  links:\n    - nextcloud-db:nextcloud-db\n  environment:\n    - UID=1000\n    - GID=1000\n    - UPLOAD_MAX_SIZE=10G\n    - APC_SHM_SIZE=128M\n    - OPCACHE_MEM_SIZE=128\n    - REDIS_MAX_MEMORY=64mb\n    - CRON_PERIOD=15m\n    - TZ=Europe/Berlin\n    - ADMIN_USER=${NEXTCLOUD_ADMIN_USER}\n    - ADMIN_PASSWORD=${NEXTCLOUD_ADMIN_PASSWORD}\n    - DB_TYPE=mysql\n    - DB_NAME=${MYSQL_DB_NAME}\n    - DB_USER=${MYSQL_USER}\n    - DB_PASSWORD=${MYSQL_PASSWORD}\n    - DB_HOST=nextcloud-db\n    - VIRTUAL_HOST=${NEXTCLOUD_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${NEXTCLOUD_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=contact@${NEXTCLOUD_SUBDOMAIN}.${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_DATA_DIR}:/data\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_CONFIG_DIR}:/config\n    - ${VOLUME_STORAGE_ROOT}/${NEXTCLOUD_APPS_DIR}:/apps2\n  ports:\n    - \"${NEXTCLOUD_WEB_PORT}:8888\"  Image utilis\u00e9e :   Nextcloud  Environnement :  Les variables d'environnement sont nombreuses :   UID  : nextcloud user id   GID  : nextcloud group id   UPLOAD_MAX_SIZE  : taille maximale d'upload de fichiers (d\u00e9fini les valeurs dans les fichiers  .htaccess  et  php.ini  (?))   APC_SHM_SIZE  : quantit\u00e9 de m\u00e9moire partag\u00e9e allou\u00e9e \u00e0 APC (Alternative Php Cache).   OPCACHE_MEM_SIZE  : taille de la m\u00e9moire cache utilis\u00e9e par OPCACHE.   REDIS_MAX_MEMORY  : taille maximale du buffer du serveur Redis   CRON_PERIOD  : p\u00e9riode d'activation du cron unix.   TZ  : time zone d\u00e9finissant la langue et l'heure serveur.   ADMIN_USER  : utilisateur poss\u00e9dant les droits administrateurs   ADMIN_PASSWORD  : mot de passe du compte administrateur   DB_TYPE  : type de la base de donn\u00e9es li\u00e9e \u00e0 l'instance   DB_NAME  : nom de la base de donn\u00e9es   DB_USER  : utilisateur nextcloud de la base de donn\u00e9es   DB_PASSWORD  : mot de passe de l'utilisateur nextcloud\n*  DB_HOST  : adresse de la base de donn\u00e9es. Correspond \u00e0 l'adresse du serveur distant ou au nom du service docker.  Volumes :  La configuration de l'instance Nextcloud se trouve dans le dossier  /config ; les fichiers h\u00e9berg\u00e9s dans le dossier  /data  et les donn\u00e9es relatives \u00e0 l'application dans  /apps2 .  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   NEXTCLOUD_VERSION  : version de l'image docker de Nextcloud utilis\u00e9e   NEXTCLOUD_MARIADB_VERSION  : version de l'image docker de MariaDB utilis\u00e9e   NEXTCLOUD_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  nextcloud  pour  nextcloud.example.com )   NEXTCLOUD_WEB_PORT  : port de l'h\u00f4te utilis\u00e9 pour acc\u00e9der \u00e0 l'application   NEXTCLOUD_ADMIN_USER  : nom de l'utilisateur admin nextcloud   NEXTCLOUD_ADMIN_PASSWORD  : mot de passe de l'utilisateur admin   NEXTCLOUD_DB_DATA_DIR  : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e   NEXTCLOUD_DATA_DIR  : dossier utilis\u00e9 comme volume pour les donn\u00e9es de Nextcloud   NEXTCLOUD_CONFIG_DIR  : dossier utilis\u00e9 comme volume pour les fichiers de configuration de Nextcloud   NEXTCLOUD_APPS_DIR  : dossier utilis\u00e9 comme volume pour les donn\u00e9es li\u00e9es \u00e0 l'application Nextcloud   VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Instance Nextcloud"
        },
        {
            "location": "/minions/rocketchat/README/",
            "text": "Work in progress",
            "title": "Rocketchat"
        },
        {
            "location": "/minions/sinopia/README/",
            "text": "Sinopia container documentation\n\uf618\n\n\nFichier compose\n\n\nSinopia\n\uf618\n\n\nSinopia est un serveur de stockage de package NPM. Il permet de stocker ses propres packages ou de stocker des pacgages officiels. Cela permet l'acc\u00e8s \u00e0 ces derniers m\u00eame que les serveurs npm sont hors ligne.\n\n\nProbl\u00e8mes rencontr\u00e9s\n\uf618\n\n\nImport des scoped packages\n\nLes packages commen\u00e7ant avec le caract\u00e8re @ ne sont pas t\u00e9l\u00e9charg\u00e9. Pour palier \u00e0 cel\u00e0, il faut modifier la configuration dans le fichier \nconfig.yaml\n comme suit :\n\n\n'@*/*':\n  # scoped packages\n  allow_access: $all\n  allow_publish: $authenticated\n  proxy: npmjs\n\n\n\n\nAjouter npmjs comment proxy pour ces packages r\u00e8gle le probl\u00e8me.\n\n\nImpossible de mapper le dossier \n/sinopia/registry\n\nEn mettant \u00e0 disposition le dossier \n/sinopia/registry\n et en le mappant dans le docker-compose, il est impossible de d\u00e9ployer l'image : le fichier \n/bin/sinopia.sh\n n'existe pas.",
            "title": "Sinopia"
        },
        {
            "location": "/minions/sinopia/README/#sinopia-container-documentation",
            "text": "Fichier compose",
            "title": "Sinopia container documentation"
        },
        {
            "location": "/minions/sinopia/README/#sinopia",
            "text": "Sinopia est un serveur de stockage de package NPM. Il permet de stocker ses propres packages ou de stocker des pacgages officiels. Cela permet l'acc\u00e8s \u00e0 ces derniers m\u00eame que les serveurs npm sont hors ligne.",
            "title": "Sinopia"
        },
        {
            "location": "/minions/sinopia/README/#problemes-rencontres",
            "text": "Import des scoped packages \nLes packages commen\u00e7ant avec le caract\u00e8re @ ne sont pas t\u00e9l\u00e9charg\u00e9. Pour palier \u00e0 cel\u00e0, il faut modifier la configuration dans le fichier  config.yaml  comme suit :  '@*/*':\n  # scoped packages\n  allow_access: $all\n  allow_publish: $authenticated\n  proxy: npmjs  Ajouter npmjs comment proxy pour ces packages r\u00e8gle le probl\u00e8me.  Impossible de mapper le dossier  /sinopia/registry \nEn mettant \u00e0 disposition le dossier  /sinopia/registry  et en le mappant dans le docker-compose, il est impossible de d\u00e9ployer l'image : le fichier  /bin/sinopia.sh  n'existe pas.",
            "title": "Probl\u00e8mes rencontr\u00e9s"
        },
        {
            "location": "/minions/taiga/README/",
            "text": "Work in progress",
            "title": "Taiga"
        },
        {
            "location": "/minions/wekan/README/",
            "text": "Conteneur Wekan\n\uf618\n\n\nDocumentation du fichier \ndocker-compose.yml\n d'un conteneur pour une instance Wekan\n\n\nWekan est un kanban opensource semblable \u00e0 \nTrello\n.\n\n\nBase de donn\u00e9es\n\uf618\n\n\nmongo:\n  restart: always\n  image: mongo:${WEKAN_MONGODB_VERSION}\n  container_name: mongodb-${WEKAN_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${WEKAN_DB_DATA_DIR}:/data/db\n\n\n\n\nImage utilis\u00e9e :\n \nMondoDB\n\n\nEnvironnement :\n\n\nAucune variable d'environnement n'est n\u00e9cessaire pour l'utilisation de ce conteneur.\n\n\nVolume :\n\n\nLe volume est associ\u00e9 au dossier \n/data/db\n du conteneur et permet de sauvegarder les donn\u00e9es de la base.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nWEKAN_MONGODB_VERSION\n : version de l'image docker de MongoDB utilis\u00e9e\n\n \nWEKAN_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nwekan\n pour \nwekan.example.com\n)\n\n \nWEKAN_DB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nInstance Wekan\n\uf618\n\n\nwekan:\n  image: mquandalle/wekan:${WEKAN_VERSION}\n  container_name: ${WEKAN_SUBDOMAIN}-${DOMAIN}\n  links:\n    - mongo:db\n  environment:\n    - VIRTUAL_HOST=${WEKAN_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${WEKAN_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${WEKAN_SUBDOMAIN}@${DOMAIN}\n    - \"MONGO_URL=mongodb://db\"\n    - \"ROOT_URL=http://${WEKAN_SUBDOMAIN}.${DOMAIN}\"\n    - MAIL_URL=puzle.project@gmail.com\n  ports:\n    - ${WEKAN_WEB_PORT}:80\n\n\n\n\nImage utilis\u00e9e :\n \nmquandalle/wekan\n\n\nEnvironnement :\n\n\nLes variables suivantes sont n\u00e9cessaires \u00e0 la configuration de Wekan :\n\n \nMONGO_URL\n : contient l'URL de la base MongoDB\n\n \nROOT_URL\n : URL vers la plate-forme Wekan. Si elle est mal configur\u00e9e, il se peut que des actions soient impossible \u00e0 cause d'une mauvaise redirection (selection des cartes ...)\n* \nMAIL_URL\n : addresse mail avec laquelle envoyer les notifications\n\n\nVolumes :\n\n\nAucun volume n'est n\u00e9cessaire au conteneur.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nWEKAN_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nwekan\n pour \nwekan.example.com\n)\n\n \nWEKAN_VERSION\n : version de l'image docker de MySQL utilis\u00e9e\n\n \nWEKAN_WEB_PORT\n : port accessible par http\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Wekan"
        },
        {
            "location": "/minions/wekan/README/#conteneur-wekan",
            "text": "Documentation du fichier  docker-compose.yml  d'un conteneur pour une instance Wekan  Wekan est un kanban opensource semblable \u00e0  Trello .",
            "title": "Conteneur Wekan"
        },
        {
            "location": "/minions/wekan/README/#base-de-donnees",
            "text": "mongo:\n  restart: always\n  image: mongo:${WEKAN_MONGODB_VERSION}\n  container_name: mongodb-${WEKAN_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${WEKAN_DB_DATA_DIR}:/data/db  Image utilis\u00e9e :   MondoDB  Environnement :  Aucune variable d'environnement n'est n\u00e9cessaire pour l'utilisation de ce conteneur.  Volume :  Le volume est associ\u00e9 au dossier  /data/db  du conteneur et permet de sauvegarder les donn\u00e9es de la base.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   WEKAN_MONGODB_VERSION  : version de l'image docker de MongoDB utilis\u00e9e   WEKAN_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  wekan  pour  wekan.example.com )   WEKAN_DB_DATA_DIR  : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Base de donn\u00e9es"
        },
        {
            "location": "/minions/wekan/README/#instance-wekan",
            "text": "wekan:\n  image: mquandalle/wekan:${WEKAN_VERSION}\n  container_name: ${WEKAN_SUBDOMAIN}-${DOMAIN}\n  links:\n    - mongo:db\n  environment:\n    - VIRTUAL_HOST=${WEKAN_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${WEKAN_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${WEKAN_SUBDOMAIN}@${DOMAIN}\n    - \"MONGO_URL=mongodb://db\"\n    - \"ROOT_URL=http://${WEKAN_SUBDOMAIN}.${DOMAIN}\"\n    - MAIL_URL=puzle.project@gmail.com\n  ports:\n    - ${WEKAN_WEB_PORT}:80  Image utilis\u00e9e :   mquandalle/wekan  Environnement :  Les variables suivantes sont n\u00e9cessaires \u00e0 la configuration de Wekan :   MONGO_URL  : contient l'URL de la base MongoDB   ROOT_URL  : URL vers la plate-forme Wekan. Si elle est mal configur\u00e9e, il se peut que des actions soient impossible \u00e0 cause d'une mauvaise redirection (selection des cartes ...)\n*  MAIL_URL  : addresse mail avec laquelle envoyer les notifications  Volumes :  Aucun volume n'est n\u00e9cessaire au conteneur.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   WEKAN_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  wekan  pour  wekan.example.com )   WEKAN_VERSION  : version de l'image docker de MySQL utilis\u00e9e   WEKAN_WEB_PORT  : port accessible par http\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Instance Wekan"
        },
        {
            "location": "/minions/wordpress/README/",
            "text": "Conteneur Wordpress\n\uf618\n\n\nDocumentation du fichier \ndocker-compose.yml\n d'un conteneur pour une instance Wordpress\n\n\nWordpress est un outil de g\u00e9n\u00e9ration et de gestion de site web simple, complet et intuitif.\n\n\nBase de donn\u00e9es\n\uf618\n\n\nmysql:\n  image: mysql:${WORDPRESS_MYSQL_VERSION}\n  container_name: mysql-${WORDPRESS_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${WORDPRESS_DB_DATA_DIR}:/var/lib/mysql\n  environment:\n    - MYSQL_ROOT_PASSWORD=${WORDPRESS_SUBDOMAIN}\n\n\n\n\nImage utilis\u00e9e :\n \nMySQL\n\n\nEnvironnement :\n\n\nLa seule variable n\u00e9cessaire ici est le mot de passe root de la base utilis\u00e9e (\nMYSQL_ROOT_PASSWORD\n).\n\n\nVolumes :\n\n\nLe volume utilis\u00e9 ici permet la r\u00e9cup\u00e9ration des donn\u00e9es de la base. Wordpress sauvegarde tout les ajouts au site directement dans la base de donn\u00e9es, ainsi mapper ce volume suffit \u00e0 la sauvegarde du contenu du site.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nWORDPRESS_MYSQL_VERSION\n : version de l'image docker de MySQL utilis\u00e9e\n\n \nWORDPRESS_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nwordpress\n pour \nwordpress.example.com\n)\n\n \nWORDPRESS_DB_DATA_DIR\n : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e\n\n \nMYSQL_ROOT_PASSWORD\n : mot de passe associ\u00e9 \u00e0 l'utilisateur root de la base de donn\u00e9es\n\n \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.\n\n\nInstance Wordpress\n\uf618\n\n\nwordpress:\n  image: beevelop/wordpress:${WORDPRESS_VERSION}\n  container_name: ${WORDPRESS_SUBDOMAIN}-${DOMAIN}\n  links:\n    - mysql:mysql\n  ports:\n    - ${WORDPRESS_WEB_PORT}:80\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${WORDPRESS_DATA_DIR}:/var/www/html\n  environment:\n    - SITE_URL=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n    - SITE_TITLE=${WORDPRESS_NAME}\n    - ADMIN_USER=${WORDPRESS_USER}\n    - ADMIN_PASSWORD=${WORDPRESS_PASSWORD}\n    - WORDPRESS_PLUGINS=\"wordfence\"\n    - WORDPRESS_ACTIVE_THEME=responsive\n    - WORDPRESS_THEMES=\"responsive\"\n    - VIRTUAL_HOST=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n\n\n\n\nImage utilis\u00e9e :\n \nbeevelop/wordpress\n\n\nEnvironnement :\n\n\nLa d\u00e9finition de l'environnement du conteneur permet d'\u00e9chapper \u00e0 la configuration manuelle de Wordpress : lors du premier acc\u00e8s \u00e0 la page, un th\u00e8me sera d\u00e9j\u00e0 install\u00e9, avec les plugins souhait\u00e9s.\n\nPour cela, il suffit de configurer ces quelques variables :\n\n \nSITE_URL\n : adresse du site web. N\u00e9cessaire pour les liens internes.\n\n \nSITE_TITLE\n : titre initial du site.\n\n \nADMIN_USER\n : nom de l'administrateur.\n\n \nADMIN_PASSWORD\n : mot de passe de l'administrateur.\n\n \nWORDPRESS_PLUGINS\n : liste des plugins \u00e0 installer \u00e0 la cr\u00e9ation. Chaque plugin doit \u00eatre s\u00e9par\u00e9 d'un point virgule.\n\n \nWORDPRESS_ACTIVE_THEME\n : th\u00e8me activ\u00e9 par d\u00e9faut lors de la cr\u00e9ation du conteneur.\n* \nWORDPRESS_THEMES\n : liste des th\u00e8mes \u00e0 installer \u00e0 la cr\u00e9ation du conteneur.\n\n\nAttention\n lors de la recr\u00e9ation du conteneur (si jamais il est n\u00e9cessaire de d\u00e9truire le conteneur et de le recr\u00e9er) a bien modifier la valeur du \nWORDPRESS_ACTIVE_THEME\n s'il a \u00e9t\u00e9 modifi\u00e9 en amont via l'interface d'administration. Le th\u00e8me activ\u00e9 par d\u00e9faut \u00e0 la cr\u00e9ation est celui renseign\u00e9 dans \nWORDPRESS_ACTIVE_THEME\n.\n\n\nVolumes :\n\n\nOn sauvegarde ici le dossier \n/var/www/html\n du conteneur : c'est le fichier o\u00f9 est installer Wordpress, les plugins install\u00e9s, les th\u00e8mes etc. Cela permet de ne pas perdre de temps avec la r\u00e9installation de Wordpress \u00e0 chaque red\u00e9marrage du conteneur.\n\n\nVariables :\n\n\nCes variables permettent de configurer le fichier \ndocker-compose.yml\n sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier \n.env\n semblable au fichier \n.env_default\n fourni :\n\n \nDOMAIN\n : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex : \nexample.com\n)\n\n \nWORDPRESS_VERSION\n : version de l'image docker de Wordpress utilis\u00e9e\n\n \nWORDPRESS_SUBDOMAIN\n : sous domaine utilis\u00e9 par l'application (ex : \nwordpress\n pour \nwordpress.example.com\n)\n\n \nWORDPRESS_NAME\n : titre initial du site.\n\n \nWORDPRESS_USER\n : nom de l'administrateur.\n\n \nWORDPRESS_PASSWORD\n : mot de passe de l'administrateur.\n\n \nWORDPRESS_WEB_PORT\n : port de redirection vers le conteneur.\n\n \nWORDPRESS_DATA_DIR\n : dossier utilis\u00e9 comme volume pour les donn\u00e9es de Wordpress\n* \nVOLUME_STORAGE_ROOT\n : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.\n\n\nNB :\n \ntoutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Wordpress"
        },
        {
            "location": "/minions/wordpress/README/#conteneur-wordpress",
            "text": "Documentation du fichier  docker-compose.yml  d'un conteneur pour une instance Wordpress  Wordpress est un outil de g\u00e9n\u00e9ration et de gestion de site web simple, complet et intuitif.",
            "title": "Conteneur Wordpress"
        },
        {
            "location": "/minions/wordpress/README/#base-de-donnees",
            "text": "mysql:\n  image: mysql:${WORDPRESS_MYSQL_VERSION}\n  container_name: mysql-${WORDPRESS_SUBDOMAIN}-${DOMAIN}\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${WORDPRESS_DB_DATA_DIR}:/var/lib/mysql\n  environment:\n    - MYSQL_ROOT_PASSWORD=${WORDPRESS_SUBDOMAIN}  Image utilis\u00e9e :   MySQL  Environnement :  La seule variable n\u00e9cessaire ici est le mot de passe root de la base utilis\u00e9e ( MYSQL_ROOT_PASSWORD ).  Volumes :  Le volume utilis\u00e9 ici permet la r\u00e9cup\u00e9ration des donn\u00e9es de la base. Wordpress sauvegarde tout les ajouts au site directement dans la base de donn\u00e9es, ainsi mapper ce volume suffit \u00e0 la sauvegarde du contenu du site.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   WORDPRESS_MYSQL_VERSION  : version de l'image docker de MySQL utilis\u00e9e   WORDPRESS_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  wordpress  pour  wordpress.example.com )   WORDPRESS_DB_DATA_DIR  : dossier utilis\u00e9 comme volume pour la base de donn\u00e9e   MYSQL_ROOT_PASSWORD  : mot de passe associ\u00e9 \u00e0 l'utilisateur root de la base de donn\u00e9es   VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Base de donn\u00e9es"
        },
        {
            "location": "/minions/wordpress/README/#instance-wordpress",
            "text": "wordpress:\n  image: beevelop/wordpress:${WORDPRESS_VERSION}\n  container_name: ${WORDPRESS_SUBDOMAIN}-${DOMAIN}\n  links:\n    - mysql:mysql\n  ports:\n    - ${WORDPRESS_WEB_PORT}:80\n  volumes:\n    - ${VOLUME_STORAGE_ROOT}/${WORDPRESS_DATA_DIR}:/var/www/html\n  environment:\n    - SITE_URL=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n    - SITE_TITLE=${WORDPRESS_NAME}\n    - ADMIN_USER=${WORDPRESS_USER}\n    - ADMIN_PASSWORD=${WORDPRESS_PASSWORD}\n    - WORDPRESS_PLUGINS=\"wordfence\"\n    - WORDPRESS_ACTIVE_THEME=responsive\n    - WORDPRESS_THEMES=\"responsive\"\n    - VIRTUAL_HOST=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_HOST=${WORDPRESS_SUBDOMAIN}.${DOMAIN}\n    - LETSENCRYPT_EMAIL=${WORDPRESS_SUBDOMAIN}.${DOMAIN}  Image utilis\u00e9e :   beevelop/wordpress  Environnement :  La d\u00e9finition de l'environnement du conteneur permet d'\u00e9chapper \u00e0 la configuration manuelle de Wordpress : lors du premier acc\u00e8s \u00e0 la page, un th\u00e8me sera d\u00e9j\u00e0 install\u00e9, avec les plugins souhait\u00e9s. \nPour cela, il suffit de configurer ces quelques variables :   SITE_URL  : adresse du site web. N\u00e9cessaire pour les liens internes.   SITE_TITLE  : titre initial du site.   ADMIN_USER  : nom de l'administrateur.   ADMIN_PASSWORD  : mot de passe de l'administrateur.   WORDPRESS_PLUGINS  : liste des plugins \u00e0 installer \u00e0 la cr\u00e9ation. Chaque plugin doit \u00eatre s\u00e9par\u00e9 d'un point virgule.   WORDPRESS_ACTIVE_THEME  : th\u00e8me activ\u00e9 par d\u00e9faut lors de la cr\u00e9ation du conteneur.\n*  WORDPRESS_THEMES  : liste des th\u00e8mes \u00e0 installer \u00e0 la cr\u00e9ation du conteneur.  Attention  lors de la recr\u00e9ation du conteneur (si jamais il est n\u00e9cessaire de d\u00e9truire le conteneur et de le recr\u00e9er) a bien modifier la valeur du  WORDPRESS_ACTIVE_THEME  s'il a \u00e9t\u00e9 modifi\u00e9 en amont via l'interface d'administration. Le th\u00e8me activ\u00e9 par d\u00e9faut \u00e0 la cr\u00e9ation est celui renseign\u00e9 dans  WORDPRESS_ACTIVE_THEME .  Volumes :  On sauvegarde ici le dossier  /var/www/html  du conteneur : c'est le fichier o\u00f9 est installer Wordpress, les plugins install\u00e9s, les th\u00e8mes etc. Cela permet de ne pas perdre de temps avec la r\u00e9installation de Wordpress \u00e0 chaque red\u00e9marrage du conteneur.  Variables :  Ces variables permettent de configurer le fichier  docker-compose.yml  sans avoir \u00e0 y mettre le nez directement. Elles sont \u00e0 renseigner dans un fichier  .env  semblable au fichier  .env_default  fourni :   DOMAIN  : nom de domaine utilis\u00e9 pour avoir acc\u00e8s au serveur (ex :  example.com )   WORDPRESS_VERSION  : version de l'image docker de Wordpress utilis\u00e9e   WORDPRESS_SUBDOMAIN  : sous domaine utilis\u00e9 par l'application (ex :  wordpress  pour  wordpress.example.com )   WORDPRESS_NAME  : titre initial du site.   WORDPRESS_USER  : nom de l'administrateur.   WORDPRESS_PASSWORD  : mot de passe de l'administrateur.   WORDPRESS_WEB_PORT  : port de redirection vers le conteneur.   WORDPRESS_DATA_DIR  : dossier utilis\u00e9 comme volume pour les donn\u00e9es de Wordpress\n*  VOLUME_STORAGE_ROOT  : dossier utilis\u00e9 pour centraliser tout les volumes utilis\u00e9s par les conteneurs Docker de l'installation.  NB :   toutes les variables \u00e0 renseign\u00e9e d\u00e9finissant des dossiers doivent contenir un chemin relatif d'origine la valeur de la variable VOLUME_STORAGE_ROOT.",
            "title": "Instance Wordpress"
        },
        {
            "location": "/wiki/FAQ/",
            "text": "Erreurs rencontr\u00e9es relatives \u00e0 Docker\n\uf618\n\n\nConteneur de base de donn\u00e9es \u00e0 cours d'espace d'\u00e9criture\n\uf618\n\n\nProbl\u00e8me :\n\n\nIl se peut qu'un conteneur d'une base de donn\u00e9e quelconque (PostgreSQL, MySql, MariaDB ...) soit incapable de s'initialiser et ressorte une erreur du genre :\n\ncould not write to file [...] no space left on device\n\nCela est du au fait que le storage driver \ndevice mapper\n utilise le file syst\u00e8me root. Ce filesystem se rempli au fur et \u00e0 mesure des donn\u00e9es utilis\u00e9es par Docker : les images, les volumes mont\u00e9s ...\n\n\nSolution :\n\n\nPour r\u00e9gler cela, il y a plusieurs solutions :\n\n\n\n\nSupprimer tout les volumes orphelins (ne poss\u00e9dant plus de container les utilisant). Pour les d\u00e9tecter, nous pouvons utiliser la commande \ndocker volume\n.\n\n\ndocker volume ls -qf dangling=true\n : liste tout les volumes orphelins\n\n\ndocker volume ls -qf dangling=true | xargs -r docker volume rm\n : supprime tout les volumes orphelins\n\n\nSupprimer les images non utilis\u00e9es\n\n\nAugmenter la limite disponible de ce filesystem.\n\n\n\n\nSolutions & warnings\n\n\nProbl\u00e8me de transfert de fichier sur Nextcloud\n\uf618\n\n\nProbl\u00e8me :\n\n\nLors de l'import de gros fichier (>2Mo) sur l'application Nextcloud, il se peut que l'erreur \nrequest entity too large\n apparaisse. Cela signifie que le fichier en cours de traitement est trop lourd pour \u00eatre accept\u00e9 par le serveur.\n\n\nCette restriction de taille de transfert peut \u00eatre effectu\u00e9 par des fichiers de config directement dans la configuration  Nextcloud (.htaccess, php.ini) ou bien par Nginx.\n\n\nSolution :\n\n\n\n\nAjouter le fichier \nnextcloud.domaine\n dans le dossier vhost.d de Nginx et ajouter la ligne \nclient_max_body_size 2000m;\n.\n\n\nV\u00e9rifier les tailles autoris\u00e9es par le fichier \n.htaccess\n ou le fichier \nphp.ini\n.",
            "title": "FAQ"
        },
        {
            "location": "/wiki/FAQ/#erreurs-rencontrees-relatives-a-docker",
            "text": "",
            "title": "Erreurs rencontr\u00e9es relatives \u00e0 Docker"
        },
        {
            "location": "/wiki/FAQ/#conteneur-de-base-de-donnees-a-cours-despace-decriture",
            "text": "Probl\u00e8me :  Il se peut qu'un conteneur d'une base de donn\u00e9e quelconque (PostgreSQL, MySql, MariaDB ...) soit incapable de s'initialiser et ressorte une erreur du genre : could not write to file [...] no space left on device \nCela est du au fait que le storage driver  device mapper  utilise le file syst\u00e8me root. Ce filesystem se rempli au fur et \u00e0 mesure des donn\u00e9es utilis\u00e9es par Docker : les images, les volumes mont\u00e9s ...  Solution :  Pour r\u00e9gler cela, il y a plusieurs solutions :   Supprimer tout les volumes orphelins (ne poss\u00e9dant plus de container les utilisant). Pour les d\u00e9tecter, nous pouvons utiliser la commande  docker volume .  docker volume ls -qf dangling=true  : liste tout les volumes orphelins  docker volume ls -qf dangling=true | xargs -r docker volume rm  : supprime tout les volumes orphelins  Supprimer les images non utilis\u00e9es  Augmenter la limite disponible de ce filesystem.   Solutions & warnings",
            "title": "Conteneur de base de donn\u00e9es \u00e0 cours d'espace d'\u00e9criture"
        },
        {
            "location": "/wiki/FAQ/#probleme-de-transfert-de-fichier-sur-nextcloud",
            "text": "Probl\u00e8me :  Lors de l'import de gros fichier (>2Mo) sur l'application Nextcloud, il se peut que l'erreur  request entity too large  apparaisse. Cela signifie que le fichier en cours de traitement est trop lourd pour \u00eatre accept\u00e9 par le serveur.  Cette restriction de taille de transfert peut \u00eatre effectu\u00e9 par des fichiers de config directement dans la configuration  Nextcloud (.htaccess, php.ini) ou bien par Nginx.  Solution :   Ajouter le fichier  nextcloud.domaine  dans le dossier vhost.d de Nginx et ajouter la ligne  client_max_body_size 2000m; .  V\u00e9rifier les tailles autoris\u00e9es par le fichier  .htaccess  ou le fichier  php.ini .",
            "title": "Probl\u00e8me de transfert de fichier sur Nextcloud"
        },
        {
            "location": "/wiki/DockerVrac/",
            "text": "Docker Command list\n\uf618\n\n\nBack to basics\n\uf618\n\n\nDocker user story\n\n\n$ docker service start\n$ docker run <image>\n$ docker service stop\n\n\n\n\nUtilities\n\n- D\u00e9finition du fichier Dockerfile :\n\n\nFROM <original image>\nRUN <cmd to set up the image>\nCMD <cmd runned by the image>\n\n\n\n\n\n\nBuild de l'image\n\n\n\n\n$ docker build -t <user>/<repository name>:<tag> .\n\n\n\n\n\n\nPush de l'image sur Docker Hub\n\n\n\n\n$ docker tag <img id> <username>/<image name>:latest\n$ docker login\n$ docker push <username>/<image name>\n\n\n\n\n\n\nListe des images\n\n\n\n\n$ docker images\n\n\n\n\n\n\nSuppression des images\n\n\n-f permet de forcer la suppression\n\n\n\n\n$ docker rmi -f <image>\n\n\n\n\n\n\nSuppression d'un container\n\n-f\n permet de forcer la suppression dans le cas o\u00f9 le container run toujours\n\n\n\n\ndocker rm <container>\n\n\n\n\n\n\nRecherche d'image existante\n\n\n\n\n$ docker search <image>\n\n\n\n\n\n\nAffichage des sorties standards d'un container\n\n\n\n\ndocker <container id> logs\n\n\n\n\n\n\nListe des processus tournant dans un container\n\n\n\n\ndocker top <container>\n\n\n\n\n\n\nR\u00e9cup\u00e9ration des carac du container\n\n\n\n\ndocker inspect <container>\n\n\n\n\n\n\nT\u00e9l\u00e9charger sans run le container\n\n\n\n\ndocker pull <image>\n\n\n\n\n\n\nExecuter un terminal dans un container\n\n\n\n\ndocker exec -it <container> bash\n\n\n\n\n\n\nLister tout les container\n\n\n\n\ndocker ps -a\n\n\n\n\n\n\nSupprimer tout les container\n\n\n\n\ndocker rm `docker ps -aq`\n\n\n\n\nDocker run\n\n\ndocker run -t -i ubuntu /bin/bash\n\n\n\n\n\n\ndocker run\n runs a container\n\n\nubuntu\n is the image run\n\n\n-t\n flag : assign a terminal inside the new container\n\n\n-i\n flag : interactive connection by grabbind the STDIN of the container\n\n\n/bin/bash\n : launches a Bash shell\n\n\n--name\n : allow to give a name to a container\n\n\n\n\nDocker run\n - Other flags\n\n\n -d : deamonize the container (run in the background)\n\n -c : add a command\n* -p : map any required network ports inside our container to our host.\n\nUse :\n\n\ndocker run -p <machine port>:<container port>\n\n\n\n\n*\n\n\nDocker ps\n - Flags\n\n* \n-l\n : informations about the last launched container\n\n\nDocker logs\n - Flags\n\n* \n-f\n : act like \ntail -f\n\n\nDocker network\n\uf618\n\n\n\n\nList all of the network\n\n\n\n\ndocker network ls\n\n\n\n\n\n\nRemove a container from the network\n\n\n\n\ndocker network disconnet <network> <container>\n\n\n\n\n\n\nCreate a network\n\n-d\n : tells docker to use driver for network type\n\n\n\n\ndocker network create -d <network type> <network name>\n\n\n\n\nLa modification d'un container Docker & soumission\n\uf618\n\n\n\u00c0 la main\n\uf618\n\n\nEn lan\u00e7ant un container avec un terminal interactif (\ndocker run -t -i <image\n), il est possible d'installer tout les softs n\u00e9cessaire au bon d\u00e9roulement du container.\n\n\nIl suffit alors de commiter les modifications sur un r\u00e9pot Docker Hub.\n\n\ndocker commit -m \"comment\" -a \"Author\" <id of the previous image> <target for the new image>\n\n\n\n\nLe Dockerfile\n\uf618\n\n\nTODO : list best practices\n\n\nDocker Compose\n\uf618\n\n\nTool for defining and running multi-container applications.\n - 3 Steps process :\n  - Define the app's environment with a Dockerfile\n  - Define the services that make up your app in a docker-compose.yml file. This allow them to run together in an isolated environment\n  - Run \ndocker-compose up\n\n\nProject name\n\n  Defined by a project name to isolate each environment. IE : keep build to interfering with each other : a project name for a unique build number -> many build at a time. This is set by using the option -p or the COMPOSE_PROJECT_NAME environment variable.\n\n\nAutomated build on Docker Hub\n\uf618\n\n\nOnly GitHub & BitBukket complient\n\n\nDocker & Docker Compose Update\n\uf618\n\n\nTODO\n\n\nDevice mapper\n\uf618\n\n\nD\u00e9finition d'une nouvelle pool\n\n\nDocker doc\n\n\nDocker environment variables\n\uf618\n\n\nIl est possible d'ajouter des variables d'environnement au sein de votre docker compose. Pour cela, trois solutions :\n\n l'option \n-f FILE\n de la commande \ndocker-compose\n. Il faut alors utiliser un chemin relatif.\n\n le tableau \nenv_file:\n \u00e0 l'int\u00e9rieur du docker compose. Encore une fois, veillez \u00e0 utiliser des chemins relatifs.\n\n\nDocker variables substitution\n\uf618\n\n\nIl est possible d'\u00e9crire des compose en d\u00e9finissant des variables. Par exemple : \nports: ${WEB_PORT}:80\n. Pour cela, il faut d\u00e9finir un fichier \n.env\n dans le m\u00eame dossier que le docker-compose.yml. Docker s'occupe de remplacer les variables par leur valeur. Vous pouvez v\u00e9rifier votre configuration via \ndocker-compose config\n.",
            "title": "Memo Docker"
        },
        {
            "location": "/wiki/DockerVrac/#docker-command-list",
            "text": "",
            "title": "Docker Command list"
        },
        {
            "location": "/wiki/DockerVrac/#back-to-basics",
            "text": "Docker user story  $ docker service start\n$ docker run <image>\n$ docker service stop  Utilities \n- D\u00e9finition du fichier Dockerfile :  FROM <original image>\nRUN <cmd to set up the image>\nCMD <cmd runned by the image>   Build de l'image   $ docker build -t <user>/<repository name>:<tag> .   Push de l'image sur Docker Hub   $ docker tag <img id> <username>/<image name>:latest\n$ docker login\n$ docker push <username>/<image name>   Liste des images   $ docker images   Suppression des images  -f permet de forcer la suppression   $ docker rmi -f <image>   Suppression d'un container -f  permet de forcer la suppression dans le cas o\u00f9 le container run toujours   docker rm <container>   Recherche d'image existante   $ docker search <image>   Affichage des sorties standards d'un container   docker <container id> logs   Liste des processus tournant dans un container   docker top <container>   R\u00e9cup\u00e9ration des carac du container   docker inspect <container>   T\u00e9l\u00e9charger sans run le container   docker pull <image>   Executer un terminal dans un container   docker exec -it <container> bash   Lister tout les container   docker ps -a   Supprimer tout les container   docker rm `docker ps -aq`  Docker run  docker run -t -i ubuntu /bin/bash   docker run  runs a container  ubuntu  is the image run  -t  flag : assign a terminal inside the new container  -i  flag : interactive connection by grabbind the STDIN of the container  /bin/bash  : launches a Bash shell  --name  : allow to give a name to a container   Docker run  - Other flags   -d : deamonize the container (run in the background)  -c : add a command\n* -p : map any required network ports inside our container to our host. \nUse :  docker run -p <machine port>:<container port>  *  Docker ps  - Flags \n*  -l  : informations about the last launched container  Docker logs  - Flags \n*  -f  : act like  tail -f",
            "title": "Back to basics"
        },
        {
            "location": "/wiki/DockerVrac/#docker-network",
            "text": "List all of the network   docker network ls   Remove a container from the network   docker network disconnet <network> <container>   Create a network -d  : tells docker to use driver for network type   docker network create -d <network type> <network name>",
            "title": "Docker network"
        },
        {
            "location": "/wiki/DockerVrac/#la-modification-dun-container-docker-soumission",
            "text": "",
            "title": "La modification d'un container Docker &amp; soumission"
        },
        {
            "location": "/wiki/DockerVrac/#a-la-main",
            "text": "En lan\u00e7ant un container avec un terminal interactif ( docker run -t -i <image ), il est possible d'installer tout les softs n\u00e9cessaire au bon d\u00e9roulement du container.  Il suffit alors de commiter les modifications sur un r\u00e9pot Docker Hub.  docker commit -m \"comment\" -a \"Author\" <id of the previous image> <target for the new image>",
            "title": "\u00c0 la main"
        },
        {
            "location": "/wiki/DockerVrac/#le-dockerfile",
            "text": "TODO : list best practices",
            "title": "Le Dockerfile"
        },
        {
            "location": "/wiki/DockerVrac/#docker-compose",
            "text": "Tool for defining and running multi-container applications.\n - 3 Steps process :\n  - Define the app's environment with a Dockerfile\n  - Define the services that make up your app in a docker-compose.yml file. This allow them to run together in an isolated environment\n  - Run  docker-compose up  Project name \n  Defined by a project name to isolate each environment. IE : keep build to interfering with each other : a project name for a unique build number -> many build at a time. This is set by using the option -p or the COMPOSE_PROJECT_NAME environment variable.",
            "title": "Docker Compose"
        },
        {
            "location": "/wiki/DockerVrac/#automated-build-on-docker-hub",
            "text": "Only GitHub & BitBukket complient",
            "title": "Automated build on Docker Hub"
        },
        {
            "location": "/wiki/DockerVrac/#docker-docker-compose-update",
            "text": "TODO",
            "title": "Docker &amp; Docker Compose Update"
        },
        {
            "location": "/wiki/DockerVrac/#device-mapper",
            "text": "D\u00e9finition d'une nouvelle pool  Docker doc",
            "title": "Device mapper"
        },
        {
            "location": "/wiki/DockerVrac/#docker-environment-variables",
            "text": "Il est possible d'ajouter des variables d'environnement au sein de votre docker compose. Pour cela, trois solutions :  l'option  -f FILE  de la commande  docker-compose . Il faut alors utiliser un chemin relatif.  le tableau  env_file:  \u00e0 l'int\u00e9rieur du docker compose. Encore une fois, veillez \u00e0 utiliser des chemins relatifs.",
            "title": "Docker environment variables"
        },
        {
            "location": "/wiki/DockerVrac/#docker-variables-substitution",
            "text": "Il est possible d'\u00e9crire des compose en d\u00e9finissant des variables. Par exemple :  ports: ${WEB_PORT}:80 . Pour cela, il faut d\u00e9finir un fichier  .env  dans le m\u00eame dossier que le docker-compose.yml. Docker s'occupe de remplacer les variables par leur valeur. Vous pouvez v\u00e9rifier votre configuration via  docker-compose config .",
            "title": "Docker variables substitution"
        }
    ]
}